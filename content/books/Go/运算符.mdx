---
title: "Go 核心原理：指针、运算符与数组比较"
date: "2024-12-19"
summary: "深入剖析 Go 语言指针变量、地址操作、自增自减规则、位运算及数组比较机制，结合代码实例进行讲解。"
status: "completed"
tech: ["Go", "Pointer", "Operator"]
github: "https://github.com/BM-laoli"
arxiv: ""
keyId: "Go"
---

# 变量


## 指针变量 ，地址值 * &


> 指针变量保存的是一个地址值，会分配独立的内存来存储一个整型数字,一个是存储值一个是获取值
>



> 当变量前有_ ，才等同于& 表示在内存中的地址 _ 表示类型
>



```go
func mian(){
  var a int = 4
  var ptr *int

  ptr  =&a 

  println("a的值",a) // 4
  println("ptr的值",*ptr) // 4
  println("ptr的值",ptr) // 8564797561
}
```



## Go的自增


1.++-- 注意，自增和自减 不能做为赋值使用，只能做为表达式



```go
a++  // 结果就是a = a+1
a--  // 结果 a = a+1
a = a++  // 会报错
```



2. 指针：所谓的指针变量就是一个内存地址的引用，看下面的代码



```go
var a int =4
var ptr int

ptr = a
fmt.Println(ptr)  // 4
a = 15
fmt.Println(ptr)  // 4

var b int =5
var pt  *int
pt = &b

fmt.Println(*pt)  // 5  
b =15
fmt.Println(pt)  // 15
```



## 关于go语言中的其他运算符


> 实际上所有的编程语言，在这方面几乎是一模一样的
>



1. 位运算



```go
// 位运算法
func wei_yun() {
	var a uint = 60      /* 60 = 0011 1100 */  
	var b uint = 13      /* 13 = 0000 1101 */
	var c uint = 0          

	c = a & b       /* 12 = 0000 1100 */
	fmt.Printf("第一行 - c 的值为 %d\n", c )

	c = a | b       /* 61 = 0011 1101 */
	fmt.Printf("第二行 - c 的值为 %d\n", c )

	c = a ^ b       /* 49 = 0011 0001 */
	fmt.Printf("第三行 - c 的值为 %d\n", c )

	c = a << 2     /* 240 = 1111 0000 */
	fmt.Printf("第四行 - c 的值为 %d\n", c )

	c = a >> 2     /* 15 = 0000 1111 */
	fmt.Printf("第五行 - c 的值为 %d\n", c )
}
```



2. Go特有的运算 * &



```go


// GO特有的运算符
func go_te() {
	var a int = 4
	var b int32
	var c float32
	var ptr *int  // *是指针变量 相当于内存地址

	
	/* 运算符实例 */
	fmt.Printf("第 1 行 - a 变量类型为 = %T\n", a );
	fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b );
	fmt.Printf("第 3 行 - c 变量类型为 = %T\n", c );

	/*  & 和 * 运算符实例 */
	ptr = &a     /* 'ptr' 包含了 'a' 变量的地址 */
	fmt.Printf("a 的值为  %d\n", a);
	fmt.Printf("*ptr 为 %d\n", *ptr);
}
```



3. 如何对比两个数组？



```go
// ======
// go语言只有后置++ 没有前置++


// go语言中如何比较两个数组呢？
func DuibiShuzu()  {
	a :=[...]int{1,2,3,4}
	b :=[...]int{1,3,4,2}
	c :=[...]int{1,2,3,4,5}
	d :=[...]int{1,2,3,4}
	

	// 注意，长度不同的不能对比的 会报一个编译错误，
	fmt.Println(a == b, a == c , a == d)
	// go语言有一个按位清零 &^
	// 只要左边的二进制位是0 那么永远是0，如果不是0 ，那么左边是什么旧是什么
	// 下面的这个例子使用了 按位运算 来控制不同的状态
	const (
		Readable = 1 << iota
		Writable 
		Executable 
	)

	// 下面的代码旧是把 可读 可执行 去掉权限 变成false
	ax := 7 // 二进制旧是 0111
	// ax = ax &^  Readable
	fmt.Println(ax == Readable) // 可读权限？
	// ax = ax &^  Executable
	fmt.Println(ax == Executable) // 可执行权限？
}
```

