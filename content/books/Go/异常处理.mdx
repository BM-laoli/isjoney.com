---
title: "Go 错误处理机制：error 接口、panic 与 recover"
date: "2024-12-19"
summary: "深入解析 Go 语言错误处理机制，包括 error 接口实现、errors.New 使用、panic/recover 恢复机制及 os.Exit 的区别。"
status: "completed"
tech: ["Go", "Error Handling", "Panic Recover"]
github: "https://github.com/BM-laoli"
arxiv: ""
keyId: "Go"
---

# 章节概述如下


> 杜宇错误处理，实际上也比较的简单，语法和使用都比较简单，这里就不分模块去解读了
>



```go
package main 
import (
	"fmt"
	"errors"
)
func main() {

}

// 1.概念一栏
// 1.1 go中么有 定义的 错误机制。
// 我们 不推荐使用五花八门的写法，一般都是团队内部统一规范

// 1.2 error 类型 实现了 error 接口 
// type error interface {
// 	Error() string
// }

// 1.3 可以通过 errors.New 来快速创建错误实例 
// error.New(" n must be in the range [0 ,12]"

// 2.实践
func GetFibonacci(n int)([]int,error)  {
	if n <0 || n>100 {
		return nil,errors.New("n shold be in [0,100]")
	}

	fibList := []int{1,1}
	for i := 0; i < n; i++ {
		fibList = append(fibList,fibList[i-2]+fibList[i-1])
	}
	return fibList,nil
}

func T1(){
	if v,err:= GetFibonacci(-10); err != nil {
		fmt.Println(err)
	}else{
		fmt.Println(v)
	}
}


// 3 关于程序的另外的退出方法 panic recover Exit
/*
panic 用于不可恢复的错误
paic 退出前会执行defer的内容

os.Exit, 不会调用defer，不会输出调用栈

recover 类似于 catch  小心哈你的catch 抓了之后 就不见了
 panic之后 会调用defer 在defer中使用revoer就好了
*/

func T2()  {
	defer func(){
		if erro := recover(); erro != nil {
			fmt.Println("recoer pacie",erro)
		}
	}()
	fmt.Println("satrt")
	panic(errors.New("errrrrrrr"))
}
```

