---
title: "Go Ginæ¡†æ¶å®æˆ˜ï¼šä»å…¥é—¨åˆ°ä¼ä¸šçº§åº”ç”¨"
date: "2024-06-18"
summary: "æ·±å…¥è®²è§£Goè¯­è¨€Ginæ¡†æ¶çš„æ ¸å¿ƒç”¨æ³•ï¼ŒåŒ…æ‹¬è·¯ç”±é…ç½®ã€ORMæ“ä½œã€JWTè®¤è¯ã€æ—¥å¿—è®°å½•å’Œä¼˜é›…é‡å¯ç­‰ä¼ä¸šçº§å¼€å‘å¿…å¤‡æŠ€èƒ½ã€‚"
status: "completed"
tech: ["Go", "Gin", "GORM", "JWT"]
github: "https://github.com/BM-laoli"
arxiv: ""
keyId: "Go"
---

> å¦‚å›¾æ‰€ç¤ºï¼Œæœ¬é˜¶æ®µ  å°†ä¼šç€é‡è¯´æ˜ï¼Œ1 éƒ¨åˆ†çš„å†…å®¹ï¼Œå’Œä¸€äº›æ³¨æ„äº‹é¡¹ä»¥åŠæ‰©å±•, gin å’Œ nodeä¸­çš„express æ¡†æ¶éå¸¸çš„åƒï¼å¦‚æœä½ èƒ½å¤Ÿä½¿ç”¨expressçš„ä¸€äº›çŸ¥è¯†æ¥ç†è§£å®ƒï¼Œæˆ‘æƒ³è¿™æ˜¯æœ€å¿«çš„ä¸Šæ‰‹æ–¹å¼
>



æœ¬é¡¹ç›®åœ°å€ï¼š

[github](https://github.com/BM-laoli/go-gin-example/tree/base)



è¿™ä¸ªé˜¶æ®µçš„å†…å®¹åŒ…å«äº†ï¼Œç…é±¼ å¤§ä½¬çš„ go å…¥é—¨ç³»åˆ—çš„ è¿è½½1-6ï¼ŒåŸºç¡€ é¡¹ç›® åˆ° æ—¥å¿—è®°å½•jwtéªŒè¯



è¯·ç‰¢è®° goçš„pack ç«™ç‚¹ï¼Œä»–å°±åƒ npmç«™ä¸€æ ·é‡è¦

[Go Packages](https://pkg.go.dev/)

#  å¼€å§‹
## å®‰è£…çš„æ—¶å€™éœ€è¦æ³¨æ„çš„äº‹æƒ…
> å®é™…ä¸Šè¿™é‡Œæ²¡æœ‰ä»€ä¹ˆéå¸¸ç‰¹åˆ«çš„ä¸œè¥¿éœ€è¦æ³¨æ„ï¼Œä¸»è¦æ˜¯Pathçš„é—®é¢˜
>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ·»åŠ ç¯å¢ƒå˜é‡ GOROOT å’Œå°† GOBIN æ·»åŠ åˆ° PATH ä¸­. è¿™ç‚¹å’Œ nodejsåœ¨å®‰è£…çš„æ—¶å€™å¾ˆç±»ä¼¼ï¼Œå¦‚æœä½ ä¸æŒ‡å®š ï¼Œæ‰¾åˆ°node è¿™ä¸ªå‘½ä»¤ï¼Œä½†æ˜¯ç°åœ¨æœ€æƒ³çš„ç‰ˆæœ¬ å·²ç»ä¸éœ€è¦è¿™æ ·äº†ï¼›ä¸jdkçš„å®‰è£…ä¹Ÿç±»ä¼¼ã€‚ï¼ˆä¸Šè¿°ä»…é’ˆå¯¹linux ç³»ç»Ÿè€Œè¨€ï¼‰</font>

```shell
# /etc/profile
export GOROOT=/usr/local/go 
export PATH=$PATH:$GOROOT/bin

```

MacOs å°±ç›´æ¥brew å°±å®Œäº†

```shell
 brew install go

# å‡çº§
 brew upgrade go
```

## æºç ç»“æ„
> å½“ä½ å®‰è£…å®Œä¹‹åï¼Œæˆ‘ä»¬å»å®ƒçš„å®‰è£…ç›®å½•ï¼Œçœ‹çœ‹å®ƒçš„æºç ç»“æ„é‡Œéƒ½æœ‰ä»€ä¹ˆä¸œè¥¿
>

```shell
go
â”œâ”€â”€ api # ç”¨äºå­˜æ”¾ä¾ç…§ Go ç‰ˆæœ¬é¡ºåºçš„ API å¢é‡åˆ—è¡¨æ–‡ä»¶ã€‚è¿™é‡Œæ‰€è¯´çš„ API åŒ…å«å…¬å¼€çš„å˜é‡ã€å¸¸é‡ã€å‡½æ•°ç­‰ã€‚
# è¿™äº› API å¢é‡åˆ—è¡¨æ–‡ä»¶ç”¨äº Go è¯­è¨€ API æ£€æŸ¥
â”œâ”€â”€ bin # ç”¨äºå­˜æ”¾ä¸»è¦çš„æ ‡å‡†å‘½ä»¤æ–‡ä»¶ï¼ˆå¯æ‰§è¡Œæ–‡ä»¶ï¼‰ï¼ŒåŒ…å«goã€godocã€gofmt
â”œâ”€â”€ blog # ç”¨äºå­˜æ”¾å®˜æ–¹åšå®¢ä¸­çš„æ‰€æœ‰æ–‡ç« 
â”œâ”€â”€ doc # ç”¨äºå­˜æ”¾æ ‡å‡†åº“çš„ HTML æ ¼å¼çš„ç¨‹åºæ–‡æ¡£ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡godocå‘½ä»¤å¯åŠ¨ä¸€ä¸ª Web ç¨‹åºå±•ç¤ºè¿™äº›æ–‡æ¡£
â”œâ”€â”€ lib # ç”¨äºå­˜æ”¾ä¸€äº›ç‰¹æ®Šçš„åº“æ–‡ä»¶
â”œâ”€â”€ misc # ç”¨äºå­˜æ”¾ä¸€äº›è¾…åŠ©ç±»çš„è¯´æ˜å’Œå·¥å…·
â”œâ”€â”€ pkg # ç”¨äºå­˜æ”¾å®‰è£…Goæ ‡å‡†åº“åçš„æ‰€æœ‰å½’æ¡£æ–‡ä»¶ï¼ˆä»¥.aç»“å°¾çš„æ–‡ä»¶ï¼‰ã€‚æ³¨æ„ï¼Œä½ ä¼šå‘ç°å…¶ä¸­æœ‰åç§°ä¸ºlinux_amd64
# çš„æ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬ç§°ä¸ºå¹³å°ç›¸å…³ç›®å½•ã€‚è¿™ç±»æ–‡ä»¶å¤¹çš„åç§°ç”±å¯¹åº”çš„æ“ä½œç³»ç»Ÿå’Œè®¡ç®—æ¶æ„çš„åç§°ç»„åˆè€Œ
# æˆã€‚é€šè¿‡go installå‘½ä»¤ï¼ŒGoç¨‹åºä¼šè¢«ç¼–è¯‘æˆå¹³å°ç›¸å…³çš„å½’æ¡£æ–‡ä»¶å­˜æ”¾åˆ°å…¶ä¸­
â”œâ”€â”€ src # ç”¨äºå­˜æ”¾ Goè‡ªèº«ã€Go æ ‡å‡†å·¥å…·ä»¥åŠæ ‡å‡†åº“çš„æ‰€æœ‰æºç æ–‡ä»¶
â”œâ”€â”€ test
â””â”€â”€ ... # å­˜æ”¾ç”¨æ¥æµ‹è¯•å’ŒéªŒè¯Goæœ¬èº«çš„æ‰€æœ‰ç›¸å…³æ–‡ä»¶

# åœ¨æˆ‘ä»¬çš„å¯æ‰§è¡Œcliçš„bin ç›®å½•ä¸‹å®ƒçš„ç»“æ„æœ‰ä¸¤ä¸ªæ–‡ä»¶
_ go # äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶
_ gifmt # æ ¼å¼åŒ–å·¥å…·
```

## Go  <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">Modules</font>
> åœ¨go11+ å¼€å¯go Modules ä¹‹åï¼Œé¡¹ç›®å¯ä»¥æ”¾åœ¨ä»»ä½•æ–‡ä»¶å¤¹çš„ä½ç½®ä¸­ï¼Œè¿™ä¸œè¥¿å°±ç±»ä¼¼æˆ‘ä»¬çš„npm 
>

```shell
# ä¸‹é¢ å®Œæ•´çš„è¡¨è¿°äº† äº†åˆ›å»ºä¸€ä¸ª å·¥ç¨‹ çš„æ‰€éœ€è¦çš„åˆå§‹åŒ–å‘½ä»¤
$ mkdir go-gin-example && cd go-gin-example

$ go env -w GO111MODULE=on # æ‰“å¼€ Go modules å¼€å…³ï¼ˆç›®å‰åœ¨ Go1.13 ä¸­é»˜è®¤å€¼ä¸º autoï¼‰ã€‚

$ go env -w GOPROXY=https://goproxy.cn,direct 
# ç½® GOPROXY ä»£ç†ï¼Œè¿™é‡Œä¸»è¦æ¶‰åŠåˆ°ä¸¤ä¸ªå€¼ï¼Œç¬¬ä¸€ä¸ªæ˜¯ https://goproxy.cnï¼Œå®ƒæ˜¯ç”±ä¸ƒç‰›äº‘èƒŒ 
# ä¹¦çš„ä¸€ä¸ªå¼ºå¤§ç¨³å®šçš„ Go æ¨¡å—ä»£ç†ï¼Œå¯ä»¥æœ‰æ•ˆåœ°è§£å†³ä½ çš„å¤–ç½‘é—®é¢˜ï¼›ç¬¬äºŒä¸ªæ˜¯ directï¼Œå®ƒæ˜¯ä¸€ä¸ªç‰¹æ®Š
# çš„ fallback é€‰é¡¹ï¼Œå®ƒçš„ä½œç”¨æ˜¯ç”¨äºæŒ‡ç¤º Go åœ¨æ‹‰å–æ¨¡å—æ—¶é‡åˆ°é”™è¯¯ä¼šå›æºåˆ°æ¨¡å—ç‰ˆæœ¬çš„æºåœ°å€å»æŠ“
# å–ï¼ˆæ¯”å¦‚ GitHub ç­‰ï¼‰ã€‚

$ go mod init github.com/EDDYCJY/go-gin-example # åˆå§‹åŒ–
# ä¸»è¦ github.com/EDDYCJY/go-gin-example å¡«å†™çš„æ˜¯æ¨¡å—å¼•å…¥è·¯å¾„ï¼Œä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„æƒ…å†µä¿®æ”¹è·¯å¾„ã€‚
go: creating new go.mod: module github.com/EDDYCJY/go-gin-example

$ ls
go.mod
```

ç”Ÿæˆçš„ go mod æ˜¯ä»€ä¹ˆï¼Œgo sum åˆæ˜¯ä»€ä¹ˆï¼Œå¯¹æ¯”npm çš„åŒ…ç®¡ç†ï¼Œä½ å¯ä»¥ç†è§£ package.json , sum å°±æ˜¯ä¸€ä¸ªyarn,lock ç±»ä¼¼çš„å­˜åœ¨, å¯¹äº sumæˆ‘ä»¬ä¸åšè¿‡å¤šçš„è§£è¯»ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ modä¸­éƒ½æ˜¯ä»€ä¹ˆï¼Œéœ€è¦ä»€ä¹ˆ

```shell
module  è¯­å¥æŒ‡å®šåŒ…çš„åå­—ï¼ˆè·¯å¾„ï¼‰
require è¯­å¥æŒ‡å®šçš„ä¾èµ–é¡¹æ¨¡å—
replace è¯­å¥å¯ä»¥æ›¿æ¢ä¾èµ–é¡¹æ¨¡å—
exclude è¯­å¥å¯ä»¥å¿½ç•¥ä¾èµ–é¡¹æ¨¡å—

# ä¸€ä¸ªç±»ä¼¼çš„ä¾‹å­å¦‚ä¸‹ 
module github.com/EDDYCJY/go-gin-example // å½“å‰mod åå­—

go 1.12 // ä¾èµ–goçš„ç‰ˆæœ¬

// å·¥ç¨‹éœ€è¦æŒ‡å®šçš„ä¾èµ–
require (
	github.com/labstack/echo v3.3.10+incompatible // indirect è¿™ä¸ªæ˜¯ä¸ç›´æ¥å¼•ç”¨ï¼Œè€Œæ˜¯ä¼ é€’ä¸‹å»
	github.com/labstack/gommon v0.2.8 // è¿™ä¸ªæ˜¯ç›´æ¥å¼•ç”¨
	github.com/mattn/go-colorable v0.1.1 // indirect
	github.com/mattn/go-isatty v0.0.7 // indirect
	github.com/valyala/fasttemplate v1.0.0 // indirect
	golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect
)
```

é‚£ä¹ˆ go get åˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿè¿˜æ˜¯ä¸€æ ·å¯ä»¥ç†è§£å®ƒå°±æ˜¯goä¸­çš„npm/yarn . å¸¸ç”¨å‘½ä»¤æœ‰ä¸‹é¢å‡ ä¸ª



```shell
go get [?xxx]
# ç”¨ go get æ‹‰å–æ–°çš„ä¾èµ–
# æ‹‰å–æœ€æ–°çš„ç‰ˆæœ¬(ä¼˜å…ˆæ‹©å– tag)ï¼šgo get golang.org/x/text@latest
# æ‹‰å– master åˆ†æ”¯çš„æœ€æ–° commitï¼šgo get golang.org/x/text@master
# æ‹‰å– tag ä¸º v0.3.2 çš„ commitï¼šgo get golang.org/x/text@v0.3.2
# æ‹‰å– hash ä¸º 342b231 çš„ commitï¼Œæœ€ç»ˆä¼šè¢«è½¬æ¢ä¸º v0.3.2ï¼šgo get golang.org/x/text@342b2e

go get -u # æ›´æ–°ç°æœ‰çš„ä¾èµ–
go mod download # ä¸‹è½½ go.mod æ–‡ä»¶ä¸­æŒ‡æ˜çš„æ‰€æœ‰ä¾èµ–
go mod tidy # æ•´ç†ç°æœ‰çš„ä¾èµ– ä¹Ÿå¯ä»¥è‡ªåŠ¨çš„å¤„ç† ä»£ç ä¸­çš„ indirect/ éindirect æŠ¥é”™
go mod graph # æŸ¥çœ‹ç°æœ‰çš„ä¾èµ–ç»“æ„
go mod init # ç”Ÿæˆ go.mod æ–‡ä»¶ (Go 1.13 ä¸­å”¯ä¸€ä¸€ä¸ªå¯ä»¥ç”Ÿæˆ go.mod æ–‡ä»¶çš„å­å‘½ä»¤)
go mod edit # ç¼–è¾‘ go.mod æ–‡ä»¶
go mod vendor # å¯¼å‡ºç°æœ‰çš„æ‰€æœ‰ä¾èµ– (äº‹å®ä¸Š Go modules æ­£åœ¨æ·¡åŒ– Vendor çš„æ¦‚å¿µ)
go mod verify # æ ¡éªŒä¸€ä¸ªæ¨¡å—æ˜¯å¦è¢«ç¯¡æ”¹è¿‡

# æ³¨æ„âš ï¸ è¿™ä¸ªæœ‰ä¸€ä¸ªissues
# https://github.com/golang/go/issues/52179  ä¹Ÿè®¸ä½ ä¸åº”è¯¥ä½¿ç”¨go get -u è€Œæ˜¯ä½¿ç”¨

$ go get ./...

```

## å…³äºGin
> è¿™ä¸ªæ˜¯ä¸ª å¼€å‘æ¡†æ¶ï¼Œä½ å¯ä»¥ç±»æ¯”express
>

```shell
# æ³¨æ„å“ˆï¼Œæˆ‘ä»¬ç»§ç»­æ²¿ç”¨ä¸Šé¢çš„ å·¥ç¨‹ 
# install
go get -u github.com/gin-gonic/gin

```



ä¸‹é¢æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„ä½¿ç”¨ 

```go
package main

import "github.com/gin-gonic/gin"

func main() {
  r := gin.Default()
  r.GET("/ping", func(c *gin.Context) {
    c.JSON(200, gin.H{
      "message": "pong",
    })
  })
  r.Run() // listen and serve on 0.0.0.0:8080
}

// è¿”å›jsonæ ¼å¼ {message ï¼špong }
```

## å…³äºæµ‹è¯•
> æµ‹è¯•çš„è¯ è¿˜æ˜¯éå¸¸çš„ç®€å•å’Œé«˜æ•ˆçš„, æˆ‘ä»¬å¯ä»¥ç›´æ¥ç”¨goå°±æä¾›å¥½çš„å•å…ƒæµ‹è¯•
>
> ä¸€ä¸ªéå¸¸ç®€æ˜çš„æ•™ç¨‹ [Go Test å•å…ƒæµ‹è¯•ç®€æ˜æ•™ç¨‹ | å¿«é€Ÿå…¥é—¨ | æå®¢å…”å…”](https://geektutu.com/post/quick-go-test.html#1-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95)
>

 

## å‡†å¤‡å‡ å¼ è¡¨
```sql
-- ä½ éœ€è¦ç”¨åˆ°çš„

```

# ä¸€ä¸ªæœ€åŸºç¡€çš„é¡¹ç›®éª¨æ¶
æœ¬å°èŠ‚å†…å®¹å®Œæˆåï¼Œä½ å°†ä¼šå¾—åˆ°ä¸‹é¢çš„ç›®å½•ç»“æ„

```shell
go-gin-example/
â”œâ”€â”€ conf
â”‚   â””â”€â”€ app.ini
â”œâ”€â”€ main.go
â”œâ”€â”€ middleware
â”œâ”€â”€ models
â”‚   â””â”€â”€ models.go
â”œâ”€â”€ pkg
â”‚   â”œâ”€â”€ e
â”‚   â”‚   â”œâ”€â”€ code.go
â”‚   â”‚   â””â”€â”€ msg.go
â”‚   â”œâ”€â”€ setting
â”‚   â”‚   â””â”€â”€ setting.go
â”‚   â””â”€â”€ util
â”‚       â””â”€â”€ pagination.go
â”œâ”€â”€ routers
â”‚   â””â”€â”€ router.go
â”œâ”€â”€ runtime
```

## go modules replace
> ç”±äºæˆ‘ä»¬æ²¡æœ‰æ¨åŒ…ï¼Œä¸Šå»ï¼Œä¸œè¥¿éƒ½æ˜¯æœ¬åœ°çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ repaace æŠŠè¿œç¨‹åœ°å€æ›¿æ¢æˆæœ¬åœ°çš„åœ°å€
>

```shell
replace (
		github.com/EDDYCJY/go-gin-example/pkg/setting => ~/go-application/go-gin-example/pkg/setting
		github.com/EDDYCJY/go-gin-example/conf    	  => ~/go-application/go-gin-example/pkg/conf
		github.com/EDDYCJY/go-gin-example/middleware  => ~/go-application/go-gin-example/middleware
		github.com/EDDYCJY/go-gin-example/models 	  => ~/go-application/go-gin-example/models
		github.com/EDDYCJY/go-gin-example/routers 	  => ~/go-application/go-gin-example/routers
)

# åŸºæœ¬ä¸Š éƒ½æ˜¯æ¯ä¸€ä¸ª éƒ½éœ€è¦è‡ªå·±å»åŠ ä¸€é ï¼Œæˆªæ­¢2022/12/23 æ—¥è¿™ä¸ªä¸ç”¨è‡ªå·±å†™äº† ä¼šè‡ªåŠ¨å¤„ç†
# å¦‚æœæœ‰é—®é¢˜è¯·çœ‹ go 18 è¿™ç§å†™æ³• replace github.com/golang-queue/queue => ../../
```



## ç¨‹åºå†…é…ç½®ï¼ˆ<font style="color:rgb(80, 161, 79);background-color:rgb(250, 250, 250);">gopkg.in</font>ï¼‰
> æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªæµè¡Œçš„å·¥å…·ğŸ”§åŒ…ï¼Œæ¥é…ç½®ç¨‹åºå†…çš„é…ç½®configä»¥åŠç®¡ç†å®ƒ [go-ini/ini: A fantastic package for INI manipulations in Go](https://ini.unknwon.io/)
>

æˆ‘ä»¬å…ˆå®‰è£…ï¼Œ

```shell
go get -u github.com/go-ini/ini
```

ç„¶åå†™ä¸ªé…ç½®.config.ini

```properties
#debug or release
RUN_MODE = debug

[app]
PAGE_SIZE = 10
JWT_SECRET = 23347$040412

[server]
HTTP_PORT = 8000
READ_TIMEOUT = 60
WRITE_TIMEOUT = 60

[database]
TYPE = mysql
USER = æ•°æ®åº“è´¦å·
PASSWORD = æ•°æ®åº“å¯†ç 
#127.0.0.1:3306
HOST = æ•°æ®åº“IP:æ•°æ®åº“ç«¯å£å·
NAME = blog
TABLE_PREFIX = blog_
```

ç„¶åå†™ä¸ªè¯»å–çš„æ–¹æ³• setting.go

```go
package setting

import (
	"log"
	"time"

	"github.com/go-ini/ini"
)

var (
	Cfg *ini.File

	RunMode string

	HTTPPort int
	ReadTimeout time.Duration
	WriteTimeout time.Duration

	PageSize int
	JwtSecret string
)

func init() {
	var err error
	Cfg, err = ini.Load("conf/app.ini")
	if err != nil {
		log.Fatalf("Fail to parse 'conf/app.ini': %v", err)
	}

	LoadBase()
	LoadServer()
	LoadApp()
}

func LoadBase() {
	RunMode = Cfg.Section("").Key("RUN_MODE").MustString("debug")
}

func LoadServer() {
	sec, err := Cfg.GetSection("server")
	if err != nil {
		log.Fatalf("Fail to get section 'server': %v", err)
	}

	HTTPPort = sec.Key("HTTP_PORT").MustInt(8000)
	ReadTimeout = time.Duration(sec.Key("READ_TIMEOUT").MustInt(60)) * time.Second
	WriteTimeout =  time.Duration(sec.Key("WRITE_TIMEOUT").MustInt(60)) * time.Second
}

func LoadApp() {
	sec, err := Cfg.GetSection("app")
	if err != nil {
		log.Fatalf("Fail to get section 'app': %v", err)
	}

	JwtSecret = sec.Key("JWT_SECRET").MustString("!@)*#)!@U#@*!@!)")
	PageSize = sec.Key("PAGE_SIZE").MustInt(10)
}
```

## ä¸€äº›å·¥å…·åŒ…ï¼ˆpkgï¼‰
> è¿™é‡Œæˆ‘ä»¬ä¸»è¦æ‰‹åŠ¨çš„å£°æ˜ å’Œä¹¦å†™httpè¿”å›ï¼Œå’Œerror message è¿”å›æ ¼å¼m, ç”¨å…¨å±€å˜é‡å»ç®¡ç†å®ƒä»¬ï¼Œè¦æ¯”è‡ªå·±æ‰‹å†™å•ç‹¬çš„å†™ å¥½å¾—å¤šå¾—å¤š
>

1. msg è¿”å›error ç»Ÿä¸€ç®¡ç†

```go
// code.go
package e

const (
	SUCCESS = 200
	ERROR = 500
	INVALID_PARAMS = 400

	ERROR_EXIST_TAG = 10001
	ERROR_NOT_EXIST_TAG = 10002
	ERROR_NOT_EXIST_ARTICLE = 10003

	ERROR_AUTH_CHECK_TOKEN_FAIL = 20001
	ERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002
	ERROR_AUTH_TOKEN = 20003
	ERROR_AUTH = 20004
)

// msg.go
package e

var MsgFlags = map[int]string {
	SUCCESS : "ok",
	ERROR : "fail",
	INVALID_PARAMS : "è¯·æ±‚å‚æ•°é”™è¯¯",
	ERROR_EXIST_TAG : "å·²å­˜åœ¨è¯¥æ ‡ç­¾åç§°",
	ERROR_NOT_EXIST_TAG : "è¯¥æ ‡ç­¾ä¸å­˜åœ¨",
	ERROR_NOT_EXIST_ARTICLE : "è¯¥æ–‡ç« ä¸å­˜åœ¨",
	ERROR_AUTH_CHECK_TOKEN_FAIL : "Tokené‰´æƒå¤±è´¥",
	ERROR_AUTH_CHECK_TOKEN_TIMEOUT : "Tokenå·²è¶…æ—¶",
	ERROR_AUTH_TOKEN : "Tokenç”Ÿæˆå¤±è´¥",
	ERROR_AUTH : "Tokené”™è¯¯",
}

func GetMsg(code int) string {
	msg, ok := MsgFlags[code]
	if ok {
		return msg
	}

	return MsgFlags[ERROR]
}
```



2. å†™ä¸€ä¸ªåˆ†é¡µçš„é€šç”¨é€»è¾‘ï¼ˆä½¿ç”¨åˆ°äº† ï¼‰go get -u github.com/unknwon/com

```go
package util

import (
	"github.com/gin-gonic/gin"
	"github.com/unknwon/com"

	"github.com/EDDYCJY/go-gin-example/pkg/setting"
)

func GetPage(c *gin.Context) int {
	result := 0
	page, _ := com.StrTo(c.Query("page")).Int()
    if page > 0 {
        result = (page - 1) * setting.PageSize
    }

    return result
}
```

## models çš„ç¼–å†™ 
> è¿™é‡Œä¸»è¦æ˜¯ä»‹ç»äº†db mysql çš„é“¾æ¥
>

1. ä¾èµ–å®‰è£…

```shell
go get -u github.com/jinzhu/gorm
go get -u github.com/go-sql-driver/mysql
```

2. ä»£ç ç¼–å†™	

```shell
package models

import (
	"log"
	"fmt"

	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"

	"github.com/EDDYCJY/go-gin-example/pkg/setting"
)

var db *gorm.DB

type Model struct {
	ID int `gorm:"primary_key" json:"id"`
	CreatedOn int `json:"created_on"`
	ModifiedOn int `json:"modified_on"`
}

func init() {
	var (
		err error
		dbType, dbName, user, password, host, tablePrefix string
	)

	sec, err := setting.Cfg.GetSection("database")
	if err != nil {
		log.Fatal(2, "Fail to get section 'database': %v", err)
	}

	dbType = sec.Key("TYPE").String()
	dbName = sec.Key("NAME").String()
	user = sec.Key("USER").String()
	password = sec.Key("PASSWORD").String()
	host = sec.Key("HOST").String()
	tablePrefix = sec.Key("TABLE_PREFIX").String()

	db, err = gorm.Open(dbType, fmt.Sprintf("%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local",
		user,
		password,
		host,
		dbName))

	if err != nil {
		log.Println(err)
	}

	gorm.DefaultTableNameHandler = func (db *gorm.DB, defaultTableName string) string  {
	    return tablePrefix + defaultTableName;
	}

	db.SingularTable(true)
	db.LogMode(true)
	db.DB().SetMaxIdleConns(10)
	db.DB().SetMaxOpenConns(100)
}

func CloseDB() {
	defer db.Close()
}
```

## Ginçš„è·¯ç”±
> Ginçš„è·¯ç”±æ¯”è¾ƒç®€å• è¿™é‡Œï¼Œä¸€ç¬”å¸¦è¿‡
>

```go
package routers

import (
    "github.com/gin-gonic/gin"

    "github.com/EDDYCJY/go-gin-example/pkg/setting"
)

func InitRouter() *gin.Engine {
    r := gin.New()

    r.Use(gin.Logger())

    r.Use(gin.Recovery())

    gin.SetMode(setting.RunMode)

    r.GET("/test", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "message": "test",
        })
    })

    return r
}
```

```go
package main

import (
	"fmt"
	"net/http"

	"github.com/EDDYCJY/go-gin-example/routers"
	"github.com/EDDYCJY/go-gin-example/pkg/setting"
)

func main() {
	router := routers.InitRouter()

	s := &http.Server{
		Addr:           fmt.Sprintf(":%d", setting.HTTPPort),
		Handler:        router,
		ReadTimeout:    setting.ReadTimeout,
		WriteTimeout:   setting.WriteTimeout,
		MaxHeaderBytes: 1 << 20,
	}

	s.ListenAndServe()
}
```

# ç¼–å†™Tag ï¼ˆæœ€ç®€å•çš„CRUDä¾‹å­ï¼‰
> æœ¬å°èŠ‚ ä¸»è¦æ˜¯ å¯¹å¦‚ä½•ç¼–å†™Tag APIçš„CRUD åšäº†è¯¦ç»†çš„è¯´æ˜ã€‚å¯¹æ•´ä¸ªè¿‡ç¨‹ä¸­ä½¿ç”¨åˆ°çš„å·¥å…·åŒ…ğŸ”§ ä¹Ÿåšäº†ç›¸å…³çš„è¯´æ˜ 
>

## è·¯ç”±
> æˆ‘ä»¬ä¸»è¦æ¥å®Œæˆä¸€ä¸ªè·¯ç”±ï¼Œå…·ä½“çš„model ï¼ˆsqlï¼‰æ“ä½œé€»è¾‘æˆ‘ä»¬å…ˆç”¨fnSql æ¥è¡¨ç¤º, æˆ‘ä»¬å…ˆå…³æ³¨è·¯ç”±çš„æ„å»º
>



é¦–å…ˆæˆ‘ä»¬æ¥çœ‹æ•´ä¸ªç›®å½•çš„ç»“æ„

```markdown
...
â”œâ”€â”€ routers
â”‚   â”œâ”€â”€ api
â”‚   â”‚   â””â”€â”€ v1
â”‚   â”‚       â””â”€â”€ tag.go
â”‚   â””â”€â”€ router.go
â””â”€â”€ main.go
...
```

```go
//  æˆ‘ä»¬å†²ä»åº•å±‚å¼€å§‹å…ˆä¸Šæ„å»ºï¼Œ(è¿™ç§æ€ç»´æ–¹å¼æ˜¯ä¸€ä¸ªä¼˜ç§€ç¨‹åºå‘˜åº”è¯¥æœ‰çš„)

//tag.go
package v1

import (
    "github.com/gin-gonic/gin"
)

//è·å–å¤šä¸ªæ–‡ç« æ ‡ç­¾
func GetTags(c *gin.Context) {
    
}

//æ–°å¢æ–‡ç« æ ‡ç­¾
func AddTag(c *gin.Context) {
    
}

//ä¿®æ”¹æ–‡ç« æ ‡ç­¾
func EditTag(c *gin.Context) {
    
}

//åˆ é™¤æ–‡ç« æ ‡ç­¾
func DeleteTag(c *gin.Context) {
    
}

// router.go
package routers

import (
    "github.com/gin-gonic/gin"

    "gin-blog/routers/api/v1"
    "gin-blog/pkg/setting"
)

func InitRouter() *gin.Engine {
    r := gin.New()

    r.Use(gin.Logger())

    r.Use(gin.Recovery())

    gin.SetMode(setting.RunMode)

    apiv1 := r.Group("/api/v1")
    {
        //è·å–æ ‡ç­¾åˆ—è¡¨
        apiv1.GET("/tags", v1.GetTags)
        //æ–°å»ºæ ‡ç­¾
        apiv1.POST("/tags", v1.AddTag)
        //æ›´æ–°æŒ‡å®šæ ‡ç­¾
        apiv1.PUT("/tags/:id", v1.EditTag)
        //åˆ é™¤æŒ‡å®šæ ‡ç­¾
        apiv1.DELETE("/tags/:id", v1.DeleteTag)
    }

    return r
}

// main.go



```

## SQLæ“ä½œmodel é€»è¾‘
> è¿™é‡Œæ˜¯ç”¨æ¥åš modelçš„åœ°æ–¹ï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„æ•°æ®æ¨¡å‹ å®šä¹‰äº†ä¸€äº›sqlæ‰§è¡Œfun
>



è¡¥å……ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼Œormä¸Šçš„hooksï¼Œå®ƒé•¿è¿™æ ·

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">gorm ä¸­çš„cb å¯ä»¥å°†å›è°ƒæ–¹æ³•å®šä¹‰ä¸ºæ¨¡å‹ç»“æ„çš„æŒ‡é’ˆï¼Œåœ¨åˆ›å»ºã€æ›´æ–°ã€æŸ¥è¯¢ã€åˆ é™¤æ—¶å°†è¢«è°ƒç”¨ï¼Œå¦‚æœä»»ä½•å›è°ƒè¿”å›é”™è¯¯ï¼Œgorm å°†åœæ­¢æœªæ¥æ“ä½œå¹¶å›æ»šæ‰€æœ‰æ›´æ”¹ã€‚</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">gorm</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ‰€æ”¯æŒçš„cbæ–¹æ³•ï¼š</font>

+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">åˆ›å»ºï¼šBeforeSaveã€BeforeCreateã€AfterCreateã€AfterSave</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ›´æ–°ï¼šBeforeSaveã€BeforeUpdateã€AfterUpdateã€AfterSave</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">åˆ é™¤ï¼šBeforeDeleteã€AfterDelete</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æŸ¥è¯¢ï¼šAfterFind</font>



```go
package models


type Tag struct {
    Model

    Name string `json:"name"`
    CreatedBy string `json:"created_by"`
    ModifiedBy string `json:"modified_by"`
    State int `json:"state"`
}

// è¿™ä¸ªæ˜¯orm åœ¨ç›´çº¿sqlçš„æ—¶å€™çš„å‡ ä¸ªhook
func (tag *Tag) BeforeCreate(scope *gorm.Scope) error {
    scope.SetColumn("CreatedOn", time.Now().Unix())

    return nil
}

func (tag *Tag) BeforeUpdate(scope *gorm.Scope) error {
    scope.SetColumn("ModifiedOn", time.Now().Unix())

    return nil
}


// ç”±äºæˆ‘ä»¬å£°æ˜äº†è¿™ä¸ªè¿”å›çš„tagsï¼Œæ‰€ä»¥ä½ ä¸éœ€è¦ æ˜¾ç¤ºçš„return
func GetTags(pageNum int, pageSize int, maps interface {}) (tags []Tag) {
    db.Where(maps).Offset(pageNum).Limit(pageSize).Find(&tags)

    return
}

func GetTagTotal(maps interface {}) (count int){
    db.Model(&Tag{}).Where(maps).Count(&count)

    return
}

func ExistTagByName(name string) bool {
    var tag Tag
    db.Select("id").Where("name = ?", name).First(&tag)
    if tag.ID > 0 {
        return true
    }

    return false
}

func AddTag(name string, state int, createdBy string) bool{
    db.Create(&Tag {
        Name : name,
        State : state,
        CreatedBy : createdBy,
    })

    return true
}

func ExistTagByID(id int) bool {
    var tag Tag
    db.Select("id").Where("id = ?", id).First(&tag)
    if tag.ID > 0 {
        return true
    }

    return false
}

func DeleteTag(id int) bool {
    db.Where("id = ?", id).Delete(&Tag{})
    return true
}

func EditTag(id int, data interface {}) bool {
    db.Model(&Tag{}).Where("id = ?", id).Updates(data)
    return true
}
```

1. <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">Tag struct{}</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼Œç”¨äº</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">Gorm</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">çš„ä½¿ç”¨ã€‚å¹¶ç»™äºˆäº†é™„å±å±æ€§</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">json</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼Œè¿™æ ·å­åœ¨</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">c.JSON</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">çš„æ—¶å€™å°±ä¼šè‡ªåŠ¨è½¬æ¢æ ¼å¼ï¼Œéå¸¸çš„ä¾¿åˆ©</font>
2. <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æœ‰äººä¼šç–‘æƒ‘</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">db</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ˜¯å“ªé‡Œæ¥çš„ï¼›å› ä¸ºåœ¨åŒä¸ª</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">models</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">åŒ…ä¸‹ï¼Œå› æ­¤</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">db *gorm.DB</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ˜¯å¯ä»¥ç›´æ¥ä½¿ç”¨çš„</font>

## validation éªŒè¯æ¥å£å­—æ®µï¼ˆ+å®ŒæˆAPIï¼‰
> æˆ‘ä»¬è¿™é‡Œå°†ä¼šå®Œå–„åŸæ¥çš„routerçš„æ‰€æœ‰çš„é€»è¾‘
>

åœ¨æ­£å¼å†™ä»£ç å‰æˆ‘ä»¬è¯´ä¸€ä¸‹ Ginåå»å‚æ•°å’Œ validataéªŒè¯å™¨çš„ç»†èŠ‚

```go
// å…³äºginå¦‚ä½•å– å‚æ•°æˆ‘ä»¬æ¥çœ‹ä¸‹é¢çš„å‡ ç§æƒ…å½¢
// 1. query å‚æ•° ï¼ˆä¸ç®¡æ˜¯get/post/put/
r.POST("/test", func(ctx *gin.Context) {

    id := ctx.Query("id")
    page := ctx.DefaultQuery("page", "0")

    fmt.Printf("id: %s; page: %s; ", id, page)

    ctx.JSON(http.StatusOK, gin.H{
        "code": 200,
        "msg":  "success",
        "data": make(map[string]string),
    })
})

// 2. params å‚æ•°
r.POST("/test/:ids/my/:is", func(ctx *gin.Context) {

    ids := ctx.Param("ids")
    is := ctx.Param("is")
    // é€šè¿‡è¿™ä¸ªæ–¹æ³•å¯ä»¥è·å–åˆ°paramsçš„å€¼ ï¼Œå¹¶ä¸”å…¶å®ƒå€¼ä¹Ÿä¾ç„¶èƒ½å¤Ÿè·å–åˆ°

    id := ctx.Query("id")
    page := ctx.DefaultQuery("page", "0")

    name := ctx.PostForm("name") // xxxx
    message := ctx.PostForm("message")

    fmt.Printf("id: %s; page: %s; name: %s; message: %s;  ids : %s; is: %s", id, page, name, message, ids, is)

    ctx.JSON(http.StatusOK, gin.H{
        "code": 200,
        "msg":  "success",
        "data": make(map[string]string),
    })
})

// 3. header
	token := ctx.GetHeader("x-token")
    fmt.Printf("this is header x-token: %s \n", token)
// è¿™ä¹Ÿå°±èƒ½è·å–è¿™äº›æ•°æ®äº†

// post put è¯·æ±‚ç­‰å¸¦åœ¨bodyä¸­çš„å‚æ•°ç±»å‹
// 4. body- jsonå‚æ•°
r.POST("/test/:ids/my/:is", func(ctx *gin.Context) {

    // è§£æjson æœ‰å¤šç§æ–¹å¼ï¼Œè¿™é‡Œåªè®²ä¸€ç§ é€šè¿‡bindJsonæ¥è§£æjsonç»“æ„ä½“
    //å®šä¹‰åŒ¿åç»“æ„ä½“ï¼Œå­—æ®µä¸jsonå­—æ®µå¯¹åº”
    var body struct {
        Email string `json:"email"`
        Name  string `json:"name"`
    }
    if err := ctx.BindJSON(&body); err != nil {
        return
    }

    fmt.Printf("email -> %s \n name -> %s", body.Email, body.Name)

    ctx.JSON(http.StatusOK, gin.H{
        "code": 200,
        "msg":  "success",
        "data": make(map[string]string),
    })
})

// 5. body- from-data (é€šç”¨ç”¨äºä¸Šä¼ æ–‡ä»¶) ä¸‹é¢æ˜¯ä¸ªä¾‹å­
r.POST("uploadFIles", func(c *gin.Context) {
		// å•æ–‡ä»¶
		// file, _ := c.FormFile("file")
		// log.Println(file.Filename)

		// dst := "./" + file.Filename
		// // ä¸Šä¼ æ–‡ä»¶è‡³æŒ‡å®šçš„å®Œæ•´æ–‡ä»¶è·¯å¾„
		// c.SaveUploadedFile(file, dst)

		// å¤šæ–‡ä»¶
		// Multipart form
		form, _ := c.MultipartForm()
		files := form.File["upload[]"]

		for _, file := range files {
			log.Println(file.Filename)

		}
		c.String(http.StatusOK, fmt.Sprintf("%d files uploaded!", len(files)))

		// c.String(http.StatusOK, fmt.Sprintf("'%s' uploaded!", file.Filename))
	})



// 6. body- xxx-wwww-form-urllencoded
r.POST("/test", func(ctx *gin.Context) {

    id := ctx.Query("id")
    page := ctx.DefaultQuery("page", "0")

    fmt.Printf("id: %s; page: %s; name: %s; message: %s", id, page, name, message)

    ctx.JSON(http.StatusOK, gin.H{
        "code": 200,
        "msg":  "success",
        "data": make(map[string]string),
    })
})


```



å…³äºvalidation ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œå®˜æ–¹æ–‡æ¡£ [https://github.com/astaxie/beego/tree/master/validation](https://github.com/astaxie/beego/tree/master/validation), å®é™…ä¸Šæˆ‘ä»¬æœ‰ä¸¤ç§æ–¹å¼ ä¸€ä¸ªå¯¹åº”ç®€å•çš„ sturctçš„éªŒè¯ï¼Œä¸€ä¸ªæ˜¯å¤æ‚ç‚¹çš„ RegExp éªŒè¯



```go
type User struct {
	Name string
	Age int
}

// ç®€å•çš„
u := User{"man", 40}
	valid := validation.Validation{}
	valid.Required(u.Name, "name")
	valid.MaxSize(u.Name, 15, "nameMax")
	valid.Range(u.Age, 0, 140, "age")
	if valid.HasErrors() {
		// validation does not pass
		// print invalid message
		for _, err := range valid.Errors {
			log.Println(err.Key, err.Message)
		}
	}
	// or use like this
	if v := valid.Max(u.Age, 140, "ageMax"); !v.Ok {
		log.Println(v.Error.Key, v.Error.Message)
	}

// å¤æ‚çš„ å®é™…ä¸Šå¥½åƒæˆ‘ä»¬ä¹Ÿä¸éœ€è¦ç”¨åˆ°æ€ä¹ˆè´Ÿè´£çš„ä¸œè¥¿
type user struct {
	Id   int
	Name string `valid:"Required;Match(/^(test)?\\w*@;com$/)"`
	Age  int    `valid:"Required;Range(1, 140)"`
}

func main() {
	valid := validation.Validation{}
	// ignore empty field valid
	// see CanSkipFuncs
	// valid := validation.Validation{RequiredFirst:true}
	u := user{Name: "test", Age: 40}
	b, err := valid.Valid(u)
	if err != nil {
		// handle error
	}
	if !b {
		// validation does not pass
		// blabla...
	}
}

// ä¸‹é¢ä¹Ÿè®¸æ˜¯ä¸€ä¸ªå¥‡æ€ªçš„ä¸œè¥¿ï¼Œä½†æ˜¯ä½ è¿˜æ˜¯æœ‰å¯èƒ½ä¼šç”¨åˆ°å®ƒ
type user struct {
	Id   int
	Name string `valid:"Required;IsMe"`
	Age  int    `valid:"Required;Range(1, 140)"`
}

func IsMe(v *validation.Validation, obj interface{}, key string) {
	name, ok:= obj.(string)
	if !ok {
		// wrong use case?
		return
	}

	if name != "me" {
		// valid false
		v.SetError("Name", "is not me!")
	}
}

func main() {
	valid := validation.Validation{}
	if err := validation.AddCustomFunc("IsMe", IsMe); err != nil {
		// hadle error
	}
	u := user{Name: "test", Age: 40}
	b, err := valid.Valid(u)
	if err != nil {
		// handle error
	}
	if !b {
		// validation does not pass
		// blabla...
	}
}
```



å¥½ï¼Œä¸Šè¿°å°±æ˜¯ä¸€ä¸ªæ‰€æœ‰çš„å‰ç½®é“ºå«äº† 



```go
func GetTags(c *gin.Context) {
    name := c.Query("name")

    maps := make(map[string]interface{})
    data := make(map[string]interface{})

    if name != "" {
        maps["name"] = name
    }

    var state int = -1
    if arg := c.Query("state"); arg != "" {
        state = com.StrTo(arg).MustInt() // comæ˜¯ä¸€ä¸ªéå¸¸ç®€å•é«˜æ•ˆçš„å·¥å…·ğŸ”§
        maps["state"] = state
    }

    code := e.SUCCESS

    data["lists"] = models.GetTags(util.GetPage(c), setting.PageSize, maps)
    data["total"] = models.GetTagTotal(maps)

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : data,
    })
}

func AddTag(c *gin.Context) {
    name := c.Query("name")
    state := com.StrTo(c.DefaultQuery("state", "0")).MustInt()
    createdBy := c.Query("created_by")

    valid := validation.Validation{}
    valid.Required(name, "name").Message("åç§°ä¸èƒ½ä¸ºç©º")
    valid.MaxSize(name, 100, "name").Message("åç§°æœ€é•¿ä¸º100å­—ç¬¦")
    valid.Required(createdBy, "created_by").Message("åˆ›å»ºäººä¸èƒ½ä¸ºç©º")
    valid.MaxSize(createdBy, 100, "created_by").Message("åˆ›å»ºäººæœ€é•¿ä¸º100å­—ç¬¦")
    valid.Range(state, 0, 1, "state").Message("çŠ¶æ€åªå…è®¸0æˆ–1")

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        if ! models.ExistTagByName(name) {
            code = e.SUCCESS
            models.AddTag(name, state, createdBy)
        } else {
            code = e.ERROR_EXIST_TAG
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : make(map[string]string),
    })
}

func EditTag(c *gin.Context) {
    id := com.StrTo(c.Param("id")).MustInt()
    name := c.Query("name")
    modifiedBy := c.Query("modified_by")

    valid := validation.Validation{}

    var state int = -1
    if arg := c.Query("state"); arg != "" {
        state = com.StrTo(arg).MustInt()
        valid.Range(state, 0, 1, "state").Message("çŠ¶æ€åªå…è®¸0æˆ–1")
    }

    valid.Required(id, "id").Message("IDä¸èƒ½ä¸ºç©º")
    valid.Required(modifiedBy, "modified_by").Message("ä¿®æ”¹äººä¸èƒ½ä¸ºç©º")
    valid.MaxSize(modifiedBy, 100, "modified_by").Message("ä¿®æ”¹äººæœ€é•¿ä¸º100å­—ç¬¦")
    valid.MaxSize(name, 100, "name").Message("åç§°æœ€é•¿ä¸º100å­—ç¬¦")

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        code = e.SUCCESS
        if models.ExistTagByID(id) {
            data := make(map[string]interface{})
            data["modified_by"] = modifiedBy
            if name != "" {
                data["name"] = name
            }
            if state != -1 {
                data["state"] = state
            }

            models.EditTag(id, data)
        } else {
            code = e.ERROR_NOT_EXIST_TAG
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : make(map[string]string),
    })
}

//åˆ é™¤æ–‡ç« æ ‡ç­¾
func DeleteTag(c *gin.Context) {
    id := com.StrTo(c.Param("id")).MustInt()

    valid := validation.Validation{}
    valid.Min(id, 1, "id").Message("IDå¿…é¡»å¤§äº0")

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        code = e.SUCCESS
        if models.ExistTagByID(id) {
            models.DeleteTag(id)
        } else {
            code = e.ERROR_NOT_EXIST_TAG
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : make(map[string]string),
    })
}

```

 ä¸Šè¿°çš„æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬éƒ½æ˜¯ç”¨query æ¥å–å€¼çš„ä¸ç®¡æ˜¯ ä½•ç§æ¥å£æ–¹å¼ï¼Œäº‹å®ä¸Šè¿™ä¹Ÿä¸æ˜¯ä¸€ä¸ªå¥½çš„ä¸»æ„ï¼Œæˆ‘ä»¬åç»­ä¼šä¿®æ”¹ä»– 

# GORMå…³è”å…³ç³»
> è¿™ä¸€å°èŠ‚ ä¸»è¦æ˜¯ å¸Œæœ›å¤§å®¶èƒ½å¯¹ gorm æœ‰æ›´å¥½çš„äº†è§£ï¼›æˆ‘ä»¬ä»¥æ„å»ºä¸€ä¸ªäºtagæœ‰**<font style="color:#DF2A3F;">å…³ç³»</font>**çš„article æ¥åšæˆ‘ä»¬çš„å®æˆ˜ç›®æ ‡
>

å½“ä½ åšå®Œä¹‹åä½ çš„é¡¹ç›®ç»“æ„å¤§æ¦‚ä¼šæ˜¯è¿™æ ·çš„

```go
go-gin-example/
â”œâ”€â”€ conf
â”‚   â””â”€â”€ app.ini
â”œâ”€â”€ main.go
â”œâ”€â”€ middleware
â”œâ”€â”€ models
â”‚   â”œâ”€â”€ article.go
â”‚   â”œâ”€â”€ models.go
â”‚   â””â”€â”€ tag.go
â”œâ”€â”€ pkg
â”‚   â”œâ”€â”€ e
â”‚   â”‚   â”œâ”€â”€ code.go
â”‚   â”‚   â””â”€â”€ msg.go
â”‚   â”œâ”€â”€ setting
â”‚   â”‚   â””â”€â”€ setting.go
â”‚   â””â”€â”€ util
â”‚       â””â”€â”€ pagination.go
â”œâ”€â”€ routers
â”‚   â”œâ”€â”€ api
â”‚   â”‚   â””â”€â”€ v1
â”‚   â”‚       â”œâ”€â”€ article.go
â”‚   â”‚       â””â”€â”€ tag.go
â”‚   â””â”€â”€ router.go
â”œâ”€â”€ runtime
```

## è·¯ç”±å ä½
```go
package v1

import (
    "github.com/gin-gonic/gin"
)

//è·å–å•ä¸ªæ–‡ç« 
func GetArticle(c *gin.Context) {
}

//è·å–å¤šä¸ªæ–‡ç« 
func GetArticles(c *gin.Context) {
}

//æ–°å¢æ–‡ç« 
func AddArticle(c *gin.Context) {
}

//ä¿®æ”¹æ–‡ç« 
func EditArticle(c *gin.Context) {
}

//åˆ é™¤æ–‡ç« 
func DeleteArticle(c *gin.Context) {
}
```

```go
func InitRouter() *gin.Engine {
    ...
    apiv1 := r.Group("/api/v1")
    {
        ...
        //è·å–æ–‡ç« åˆ—è¡¨
        apiv1.GET("/articles", v1.GetArticles)
        //è·å–æŒ‡å®šæ–‡ç« 
        apiv1.GET("/articles/:id", v1.GetArticle)
        //æ–°å»ºæ–‡ç« 
        apiv1.POST("/articles", v1.AddArticle)
        //æ›´æ–°æŒ‡å®šæ–‡ç« 
        apiv1.PUT("/articles/:id", v1.EditArticle)
        //åˆ é™¤æŒ‡å®šæ–‡ç« 
        apiv1.DELETE("/articles/:id", v1.DeleteArticle)
    }

    return r
}
```

## model é€»è¾‘ï¼ˆå…³è”å…³ç³»Gormï¼‰
> æœ‰å…³sqlçš„å­¦ä¹ ï¼Œæˆ‘åªæ¨è [MySQL UNIQUE çº¦æŸ | æ–°æ‰‹æ•™ç¨‹](https://www.begtut.com/mysql/mysql-unique-constraint.html) è¿™ä¸ªç«™ç‚¹
>
> é¦–å…ˆæˆ‘ä»¬éœ€è¦äº†è§£gormçš„æ–‡æ¡£ï¼Œè¿™é‡Œå°±ä¸å±•å¼€è¯¦ç»†çš„è¯´æ˜äº†ï¼›[GORM æŒ‡å—](https://gorm.io/zh_CN/docs/)
>

ä¸‹é¢æˆ‘ä»¬ç”¨ä¸€å¼ å›¾æ¥è¯´æ˜ ï¼Œå¤šè¡¨ä¹‹é—´å¯èƒ½å­˜åœ¨çš„å…³ç³»ï¼Œè¿™é‡Œæ˜¯æœ‰å…³çš„ æ–‡ç«    
[äº§å“ç»ç†å¿…é¡»æ‡‚çš„å…³ç³»æ¨¡å‹ï¼šä¸€å¯¹ä¸€ï¼Œä¸€å¯¹å¤šä»¥åŠå¤šå¯¹å¤šå…³ç³» | äººäººéƒ½æ˜¯äº§å“ç»ç†](https://www.woshipm.com/pmd/5176906.html)

[æ•°æ®åº“ä¸­å¤šè¡¨ä¹‹é—´çš„å…³ç³»_kdå‡¯æ–‡çš„åšå®¢-CSDNåšå®¢_å¤šè¡¨ä¹‹é—´çš„å…³ç³»](https://blog.csdn.net/duanyaowei/article/details/106180233)

æ¦‚å¿µæœ‰ä¸‹é¢ï¼š

è¡¨è¡¨é—´çš„å…³ç³»æœ‰ä¸‰ç§ï¼ˆä¸€å¯¹ä¸€ ï¼Œä¸€å¯¹å¤š/å¤šå¯¹ä¸€ï¼Œ å¤šå¯¹å¤šï¼‰ï¼Œä¸»é”® æ‰€åœ¨çš„è¡¨æ˜¯ä¸»è¡¨ï¼Œä¸»å¥ å»ºç«‹çš„åœ¨ å°‘çš„ä¸€æ–¹ï¼Œåœ¨â€œå¤šâ€çš„ä¸€æ–¹å»ºç«‹ å¤–å¥ å»é“¾æ¥ â€œå°‘â€çš„ä¸€æ–¹çš„ä¸»é”®



![](https://cdn.nlark.com/yuque/0/2022/png/1627571/1672367651241-4334b8ba-f20f-4f5d-9f2d-9f105d3f035e.png)![](https://cdn.nlark.com/yuque/0/2022/png/1627571/1672367684562-91f509ee-c3b0-4172-926c-66002935cf7d.png)![](https://cdn.nlark.com/yuque/0/2022/png/1627571/1672367755972-c74be166-b497-40f2-83a3-9458a70688c7.png)

å¯¹äºè¡¨çš„å»ºç«‹ å’ŒSQLçš„æŸ¥è¯¢ï¼Œæœ‰ä¸‹é¢çš„ä¸€äº›ä¾‹å­å¯ä¾›å‚è€ƒï¼ˆä»¥Mysqlä¸ºä¾‹å­ï¼‰

è¿™é‡Œæ¨èä¸¤ç‰‡æ–‡ç«  ï¼Œè¦çŸ¥é“å®é™…ä¸Šï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ ä»€ä¹ˆå¼ºç¡¬çš„è§„åˆ™è¯´å¤šå¯¹å¤šä¸€å¯¹ä¸€ï¼Œåªæ˜¯çœ‹å¤–å¥çš„è®¾ç½®è§„åˆ™

[5.MySQLå»ºç«‹è¡¨çš„å…³ç³»ï¼ˆå¤–é”®ï¼‰_æ”¾çºµflyçš„åšå®¢-CSDNåšå®¢_mysqlåˆ›å»ºè¡¨å¤–é”®](https://blog.csdn.net/m0_52559893/article/details/121187821?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-121187821-blog-82872984.pc_relevant_landingrelevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-121187821-blog-82872984.pc_relevant_landingrelevant&utm_relevant_index=3)

[MySQL UNIQUE çº¦æŸ | æ–°æ‰‹æ•™ç¨‹](https://www.begtut.com/mysql/mysql-unique-constraint.html)

```sql
-- ä¸‹é¢ğŸ‘‡æ˜¯ä¸€äº›sql æ¥æ„å»º å’ŒæŸ¥è¯¢å¤šè¡¨
--ï¼ˆæˆ‘ä»¬ä¸¾ä¸ªä¾‹å­æ¥çœ‹ Userç”¨æˆ·è¡¨ï¼ŒOrderè®¢å•è¡¨ï¼ŒOrderdetailè®¢å•è¯¦æƒ…ï¼Œitemå•†å“è¡¨ ï¼‰
-- ä¸‹é¢çš„å…³ç³»å¦‚ä¸‹ï¼š ä¸€ä¸ªç”¨æˆ·å¯¹åº”å¤šä¸ªè®¢å•ï¼Œä¸€ä¸ªè®¢å•åªèƒ½å¯¹åº”ä¸€ä¸ªç”¨æˆ·ï¼›ä¸€ä¸ªè®¢å•å¯¹åº”å¤šä¸ªè®¢å•è¯¦æƒ…ï¼Œ
-- ä¸€ä¸ªè®¢å•è¯¦æƒ…åªå¯¹åº”ä¸€ä¸ªè®¢å•ï¼›ä¸€ä¸ªè®¢å•è¯¦æƒ…åªå¯¹åº”ä¸€ä¸ªå•†å“ï¼Œä¸€ä¸ªå•†å“å¯ä»¥åŒ…æ‹¬åœ¨å¤šä¸ªè®¢å•è¯¦æƒ…ä¸­ï¼›
-- æ‰€ä»¥ï¼Œç”¨æˆ·å’Œå•†å“ä¹‹é—´æ˜¯å¤šå¯¹å¤šå…³ç³»

-- è¿›å…¥mysql åˆ›å»ºä¸€ä¸ªåº“ ç”¨æ¥åšæ¼”ç¤º
CREATE DATABASE GODEMO;
SHOW DATANASES;
USE GODEMO;

-- åˆ›å»º å‡ å¼ å…³ç³»è¡¨
-- æ³¨æ„ä¸‹é¢çš„å‡ ä¸ªè¯­æ³•è¯´æ˜
-- KEY `FK_user` (`user_id`) è®¾ç½®å¤–å¥å

-- è®¾ç½®å¤–å¥çº¦æŸ 
-- [CONSTRAINT <å¤–é”®å>] FOREIGN KEY å­—æ®µå [ï¼Œå­—æ®µå2ï¼Œâ€¦] REFERENCES [å…³è”åˆ°å“ªé‡Œå»]
-- CONSTRAINT `FK_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) 

-- ä¸‹é¢æ˜¯ä¸€äº›å¯é€‰é¡¹
-- on update cascade  åŒæ­¥æ›´æ–°
-- on delete cascade  åŒæ­¥åˆ é™¤

CREATE TABLE `user` (
  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT 'å®¢æˆ·id(ä¸»é”®)',
  `username` varchar(32) NOT NULL COMMENT 'å®¢æˆ·åç§°',
  `birthday` date DEFAULT NULL COMMENT 'å®¢æˆ·ç”Ÿæ—¥',
  `sex` char(1) DEFAULT NULL COMMENT 'å®¢æˆ·æ€§åˆ«',
  `address` varchar(256) DEFAULT NULL COMMENT 'å®¢æˆ·åœ°å€',
  PRIMARY KEY (`id`)
  -- ON UPDATE CASCADE æˆ‘è¿™é‡Œå°±ä¸åŠ äº†
  -- ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

CREATE TABLE `orders` (
  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT 'å®¢æˆ·id(ä¸»é”®)',
  `user_id` bigint(32) NOT NULL COMMENT 'ä¸‹å•å®¢æˆ·id(å¤–é”®)',
  `number` varchar(32) NOT NULL COMMENT 'è®¢å•å·',
  `createtime` datetime NOT NULL COMMENT 'åˆ›å»ºæ—¶é—´',
  `note` varchar(32) DEFAULT NULL COMMENT 'å¤‡æ³¨',
  PRIMARY KEY (`id`),
    -- å»ºç«‹ç´¢å¼•ï¼ˆä¼˜åŒ–ç”¨ï¼‰
  KEY `FK_user` (`user_id`),
    -- å»ºç«‹å¤–å¥çº¦æŸ
  CONSTRAINT `FK_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

CREATE TABLE `orderdetail` (
  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT 'id(ä¸»é”®)',
  `order_id` bigint(32) NOT NULL COMMENT 'è®¢å•id',
  `item_id` bigint(32) NOT NULL COMMENT 'å•†å“id',
  `item_num` bigint(32) DEFAULT NULL COMMENT 'å•†å“è´­ä¹°æ•°é‡',
  PRIMARY KEY (`id`),
  KEY `order_id` (`order_id`),
  KEY `orderdetail_ibfk_2_idx` (`item_id`),
  CONSTRAINT `orderdetail_ibfk_1` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`),
  CONSTRAINT `orderdetail_ibfk_2` FOREIGN KEY (`item_id`) REFERENCES `item` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;

CREATE TABLE `item` (
  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT 'id(ä¸»é”®)',
  `name` varchar(32) NOT NULL COMMENT 'å•†å“åç§°',
  `price` float(10,1) NOT NULL COMMENT 'å•†å“ä»·æ ¼',
  `detail` text COMMENT 'å•†å“æè¿°',
  `pic` varchar(512) DEFAULT NULL COMMENT 'å•†å“å›¾ç‰‡',
  `createtime` datetime DEFAULT NULL COMMENT 'ç”Ÿäº§æ—¥æœŸ',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- æ³¨æ„è¿™ä¸ªè¡¨å®é™…ä¸Šæ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«å¤§çš„æ„ä¹‰ï¼Œè¿™é‡Œä»…ä»…æ˜¯æ¼”ç¤º
CREATE TABLE `usertoitem` (
  `id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT 'id(ä¸»é”®)',
  `item_id` bigint(32) NOT NULL COMMENT 'å•†å“id',
  `user_id` bigint(32) NOT NULL COMMENT 'ç”¨æˆ·id',
  PRIMARY KEY (`id`),
  CONSTRAINT `usertoitem_ibfk_1` FOREIGN KEY (`item_id`) REFERENCES `item`(`id`),
  CONSTRAINT `usertoitem_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user`(`id`)
) ENGINE = InnoDB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8;

-- ç®€å•çš„çœ‹çœ‹å¦‚ä½•æ–°å¢ æ•°æ® å’ŒæŸ¥è¯¢æ•°æ® CURD (CR) --> UD ä¹Ÿç±»ä¼¼ å±äºsqlçŸ¥è¯† è¿™é‡Œä¸è¯¦ç»†è¯´æ˜äº† 
-- å»ºç«‹user 
INSERT INTO user (username, birthday, sex, address)
VALUES (
    'AIKEN',
    NOW(),
    2,
    'address:varchar'
  );
-- å»ºç«‹item
SELECT *
FROM user
INSERT INTO item (name, price, detail, pic, createtime)
VALUES (
    'P3',
    111.3,
    'P3_',
    'P3_img',
    NOW()
  );

-- åˆ›å»ºä¸€ä¸ªorder
INSERT INTO orders (user_id, number, createtime, note)
VALUES (
    8,
    '8u2uwbUBU',
    NOW(),
    'note:varchar'
  );

-- ç»™è¿™ä¸ªè®¢å•åŠ ä¸‰ä¸ªitem
INSERT INTO orderdetail (order_id, item_id, item_num)
VALUES (9, 5, 12423);
INSERT INTO orderdetail (order_id, item_id, item_num)
VALUES (9, 7, 12423);
INSERT INTO orderdetail (order_id, item_id, item_num)
VALUES (9, 7, 12423);

-- ç»™usertoitem è¡¨æ·»åŠ æ•°æ® ï¼ˆä¸‹é¢ä»…ä»…æ˜¯æ·»åŠ ä¸€æ¡è®°å½•ï¼Œä½ å¯ä»¥æ¢item_idæ·»åŠ å¤šæ¡ï¼‰
INSERT INTO usertoitem (item_id, user_id)
VALUES (
    6,
    10 
  );

-- æŸ¥è¯¢æŸç”¨æˆ·çš„ orderDetail 
SELECT *
FROM orderdetail
  LEFT JOIN orders ON orderdetail.order_id = orders.id
  LEFT JOIN user ON orders.user_id = user.id
WHERE orders.user_id = 8;

-- æŸ¥è¯¢æŸç”¨æˆ·çš„ æ‰€æœ‰item
SELECT * 
FROM usertoitem
  LEFT JOIN user ON user_id = user.id
  LEFT JOIN item ON usertoitem.item_id = item.id
WHERE user_id = 8;

```

è¯·è®°ä½ï¼Œä»»ä½•orm éƒ½æ˜¯ä¸€ç§å·¥å…·ğŸ”§æ–¹ä¾¿ä½ å¼€å‘æ–¹ä¾¿å’Œç¼–ç¨‹è¯­è¨€å±‚é¢çš„é…åˆï¼Œ SQLè¯­æ³•æ‰æ˜¯é€šç”¨çš„æ ¹ï¼ï¼Œæ‰€ä»¥ä½ å¯ä»¥ç”¨orm ä½†ä¸€å®šä¸è¦å¿˜å•¦sqlï¼

```go
// é€šè¿‡å‰é¢çš„å­¦ä¹ æˆ‘ä»¬éƒ½æ˜ç™½äº† gormçš„ä¸€èˆ¬æ“ä½œã€‚ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹å…³äºgormçš„å¤šè¡¨æ“ä½œ
// ç”±äºä¸Šé¢è¯´çš„SQL ä¾‹å­ ä¹ˆæœ‰åŠæ³•ç”¨å°½ gormä¸­çš„å¤šè¡¨æ“ä½œå…³ç³»ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¾ç„¶ä»¥gormå®˜æ–¹ä¸ºå‡†

// BelongTo è¿™ç§æ¨¡å‹çš„æ¯ä¸€ä¸ªå®ä¾‹éƒ½â€œå±äºâ€å¦ä¸€ä¸ªæ¨¡å‹çš„ä¸€ä¸ªå®ä¾‹ã€‚
// `User` å±äº `Company`ï¼Œ`CompanyID` æ˜¯å¤–é”®
type User struct {
  gorm.Model
  Name      string
  CompanyID int
  Company   Company
}

type Company struct {
  ID   int
  Name string
}


// has one ä¸å¦ä¸€ä¸ªæ¨¡å‹å»ºç«‹ä¸€å¯¹ä¸€çš„å…³è”ï¼Œä½†å®ƒå’Œä¸€å¯¹ä¸€å…³ç³»æœ‰äº›è®¸ä¸åŒã€‚ 
// è¿™ç§å…³è”è¡¨æ˜ä¸€ä¸ªæ¨¡å‹çš„æ¯ä¸ªå®ä¾‹éƒ½åŒ…å«æˆ–æ‹¥æœ‰å¦ä¸€ä¸ªæ¨¡å‹çš„ä¸€ä¸ªå®ä¾‹ã€‚æˆ‘ä»¬ç”¨ gormçš„ä¾‹å­åšè¯´æ˜
// User æœ‰ä¸€å¼  CreditCardï¼ŒUserID æ˜¯å¤–é”® ä¸”æ¯ä¸ª user åªèƒ½æœ‰ä¸€å¼  credit cardã€‚
type User struct {
  gorm.Model
  CreditCard CreditCard
}

type CreditCard struct {
  gorm.Model
  Number string
  UserID uint // è¿™å°±æ˜¯ä¸€å¯¹ä¸€ 
}

// has Many ä¸åŒäº has oneï¼Œæ‹¥æœ‰è€…å¯ä»¥æœ‰é›¶æˆ–å¤šä¸ªå…³è”æ¨¡å‹ã€‚ æ¯ä¸ª user å¯ä»¥æœ‰å¤šå¼  credit cardã€‚
// User æœ‰å¤šå¼  CreditCardï¼ŒUserID æ˜¯å¤–é”®
type User struct {
  gorm.Model
  CreditCards []CreditCard
}

type CreditCard struct {
  gorm.Model
  Number string
  UserID uint
}

// Many to Many ä¼šåœ¨ä¸¤ä¸ª model ä¸­æ·»åŠ ä¸€å¼ è¿æ¥è¡¨ã€‚GORM ä¼šè‡ªåŠ¨åˆ›å»ºè¿æ¥è¡¨
// User æ‹¥æœ‰å¹¶å±äºå¤šç§ languageï¼Œ`user_languages` æ˜¯è¿æ¥è¡¨
type User struct {
  gorm.Model
  Languages []Language `gorm:"many2many:user_languages;"`
}

type Language struct {
  gorm.Model
  Name string
}

// è‡ªå®šä¹‰çš„ä¸­é—´è¡¨ ï¼ˆå®é™…ä¸šåŠ¡ä¸­ è¿™ç§æƒ…å†µå±…å¤šï¼‰
type Person struct {
  ID        int
  Name      string
  Addresses []Address `gorm:"many2many:person_addresses;"`
}

type Address struct {
  ID   uint
  Name string
}

type PersonAddress struct {
  PersonID  int `gorm:"primaryKey"`
  AddressID int `gorm:"primaryKey"`
  CreatedAt time.Time
  DeletedAt gorm.DeletedAt
}

func (PersonAddress) BeforeCreate(db *gorm.DB) error {
  // ...
}

// ä¿®æ”¹ Person çš„ Addresses å­—æ®µçš„è¿æ¥è¡¨ä¸º PersonAddress
// PersonAddress å¿…é¡»å®šä¹‰å¥½æ‰€éœ€çš„å¤–é”®ï¼Œå¦åˆ™ä¼šæŠ¥é”™
err := db.SetupJoinTable(&Person{}, "Addresses", &PersonAddress{})


// **åˆ›å»ºæ•°æ®å’Œä¿®æ”¹æ•°æ®**
user := User{
  Name:            "jinzhu",
  BillingAddress:  Address{Address1: "Billing Address - Address 1"},
  ShippingAddress: Address{Address1: "Shipping Address - Address 1"},
  Emails:          []Email{
    {Email: "jinzhu@example.com"},
    {Email: "jinzhu-2@example.com"},
  },
  Languages:       []Language{
    {Name: "ZH"},
    {Name: "EN"},
  },
}

db.Create(&user) // åˆ›å»º
db.Save(&user) // æ›´æ–°


// **æŸ¥è¯¢ ğŸ“–æ³¨æ„ æŸ¥è¯¢æœ‰å¾ˆå¤šæ–¹å¼æˆ‘ä»¬ä¸¾ä¾‹å‡ ä¸ªå¥½å§ï¼Œå‰©ä¸‹çš„åœ¨æ–‡æ¡£ä¸­**
db.Model(&user).Association("Languages").Find(&languages)
codes := []string{"zh-CN", "en-US", "ja-JP"}
db.Model(&user).Where("code IN ?", codes).Association("Languages").Find(&languages)
db.Model(&user).Where("code IN ?", codes).Order("code desc").Association("Languages").Find(&languages)

// é¢„åŠ è½½ä¸€äº›æ•°æ®
type User struct {
  gorm.Model
  Username string
  Orders   []Order
}

type Order struct {
  gorm.Model
  UserID uint
  Price  float64
}

// æŸ¥æ‰¾ user æ—¶é¢„åŠ è½½ç›¸å…³ Order
db.Preload("Orders").Find(&users)
// SELECT * FROM users;
// SELECT * FROM orders WHERE user_id IN (1,2,3,4);

db.Preload("Orders").Preload("Profile").Preload("Role").Find(&users)
// SELECT * FROM users;
// SELECT * FROM orders WHERE user_id IN (1,2,3,4); // has many
// SELECT * FROM profiles WHERE user_id IN (1,2,3,4); // has one
// SELECT * FROM roles WHERE id IN (4,5,6); // belongs to


```

```go
// è¿™é‡Œçš„ä¾‹å­æ˜¯ å…³äºtag å’Œ article ä¹‹é—´çš„å…³ç³»ï¼Œä»–ä»¬å±äº  belong to 
package models

import (
    "time"

    "github.com/jinzhu/gorm"
)

type Article struct {
    Model

    TagID int `json:"tag_id" gorm:"index"`//// ç›´æ¥ç”¨å®ƒ åšä¸ºå¤–å¥ ç›®å‰tag å’Œarticle ï¼Œä¸ºbelong to å…³ç³»
Â·    Tag   Tag `json:"tag"` 

    Title string `json:"title"`
    Desc string `json:"desc"`
    Content string `json:"content"`
    CreatedBy string `json:"created_by"`
    ModifiedBy string `json:"modified_by"`
    State int `json:"state"`
}


// æ˜¯å¦å·²ç»å­˜åœ¨
func ExistArticleByID(id int) bool {
    var article Article
    db.Select("id").Where("id = ?", id).First(&article)

    if article.ID > 0 {
        return true
    }

    return false
}

// è·å–æ€»æ•°æ®
func GetArticleTotal(maps interface {}) (count int){
    db.Model(&Article{}).Where(maps).Count(&count)

    return
}

// è·å–è¯¦æƒ…ï¼Œç”¨åˆ°äº† é¢„åŠ è½½ å’Œåˆ†é¡µ
func GetArticles(pageNum int, pageSize int, maps interface {}) (articles []Article) {
    db.Preload("Tag").Where(maps).Offset(pageNum).Limit(pageSize).Find(&articles)

    return
}

// è·å–æŸæ–‡ç« å…·ä½“è¯¦æƒ… Related æŸ¥è¯¢
func GetArticle(id int) (article Article) {
    db.Where("id = ?", id).First(&article)
    db.Model(&article).Related(&article.Tag)
    // è¡¥å……ä¸€ä¸ªè¯é¢˜ https://segmentfault.com/q/1010000021168438
/*

    db.Model(&user).Related(&company) user æ˜¯æºï¼Œcompany è¯´ å…³è”æºä¸­çš„å­—æ®µåï¼Œè¿™æ®µ
ä¸»è¦æ˜¯æ„æ€æ˜¯ æŸ¥user -> company

    db.Model(&user).Association("company").Find(&company)
è¿™æ®µè¯´çš„æ„æ€æ˜¯ ã€‚companyè¡¨æ˜¯è¦æŸ¥ä¸»è¡¨ æºï¼Œä¸»æŸ¥companyè¡¨ã€‚userå®ä¾‹åªæ˜¯æ¡ä»¶å¡«å……å¯¹è±¡

*/
    return
}

// ç¼–è¾‘
func EditArticle(id int, data interface {}) bool {
    db.Model(&Article{}).Where("id = ?", id).Updates(data)

    return true
}

// æ–°å¢
func AddArticle(data map[string]interface {}) bool {
    db.Create(&Article {
        TagID : data["tag_id"].(int),
        Title : data["title"].(string),
        Desc : data["desc"].(string),
        Content : data["content"].(string),
        CreatedBy : data["created_by"].(string),
        State : data["state"].(int),
    })

    return true
}

// åˆ é™¤
func DeleteArticle(id int) bool {
    db.Where("id = ?", id).Delete(Article{})

    return true
}

// ä¸¤ä¸ªmodel hook
func (article *Article) BeforeCreate(scope *gorm.Scope) error {
    scope.SetColumn("CreatedOn", time.Now().Unix())

    return nil
}

func (article *Article) BeforeUpdate(scope *gorm.Scope) error {
    scope.SetColumn("ModifiedOn", time.Now().Unix())

    return nil
}
```

## è·¯ç”±å…·ä½“çš„é€»è¾‘
> è¿™é‡Œçš„é€»è¾‘å°±æ¯”è¾ƒçš„ç®€å•ï¼Œæˆ‘ä»¬åªéœ€è¦è·å– httpçš„æŠ¥æ–‡ ï¼Œç„¶åå»è§£æï¼Œå»éªŒè¯ï¼Œå»å­˜å…¥åº“å°±å¥½å•¦
>

```go
package v1

import (
    "net/http"
    "log"

    "github.com/gin-gonic/gin"
    "github.com/astaxie/beego/validation"
    "github.com/unknwon/com"

    "github.com/EDDYCJY/go-gin-example/models"
    "github.com/EDDYCJY/go-gin-example/pkg/e"
    "github.com/EDDYCJY/go-gin-example/pkg/setting"
    "github.com/EDDYCJY/go-gin-example/pkg/util"
)

//è·å–å•ä¸ªæ–‡ç« 
func GetArticle(c *gin.Context) {
    id := com.StrTo(c.Param("id")).MustInt()

    valid := validation.Validation{}
    valid.Min(id, 1, "id").Message("IDå¿…é¡»å¤§äº0")

    code := e.INVALID_PARAMS
    var data interface {}
    if ! valid.HasErrors() {
        if models.ExistArticleByID(id) {
            data = models.GetArticle(id)
            code = e.SUCCESS
        } else {
            code = e.ERROR_NOT_EXIST_ARTICLE
        }
    } else {
        for _, err := range valid.Errors {
            log.Printf("err.key: %s, err.message: %s", err.Key, err.Message)
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : data,
    })
}

//è·å–å¤šä¸ªæ–‡ç« 
func GetArticles(c *gin.Context) {
    data := make(map[string]interface{})
    maps := make(map[string]interface{})
    valid := validation.Validation{}

    var state int = -1
    if arg := c.Query("state"); arg != "" {
        state = com.StrTo(arg).MustInt()
        maps["state"] = state

        valid.Range(state, 0, 1, "state").Message("çŠ¶æ€åªå…è®¸0æˆ–1")
    }

    var tagId int = -1
    if arg := c.Query("tag_id"); arg != "" {
        tagId = com.StrTo(arg).MustInt()
        maps["tag_id"] = tagId

        valid.Min(tagId, 1, "tag_id").Message("æ ‡ç­¾IDå¿…é¡»å¤§äº0")
    }

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        code = e.SUCCESS

        data["lists"] = models.GetArticles(util.GetPage(c), setting.PageSize, maps)
        data["total"] = models.GetArticleTotal(maps)

    } else {
        for _, err := range valid.Errors {
            log.Printf("err.key: %s, err.message: %s", err.Key, err.Message)
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : data,
    })
}

//æ–°å¢æ–‡ç« 
func AddArticle(c *gin.Context) {
    tagId := com.StrTo(c.Query("tag_id")).MustInt()
    title := c.Query("title")
    desc := c.Query("desc")
    content := c.Query("content")
    createdBy := c.Query("created_by")
    state := com.StrTo(c.DefaultQuery("state", "0")).MustInt()

    valid := validation.Validation{}
    valid.Min(tagId, 1, "tag_id").Message("æ ‡ç­¾IDå¿…é¡»å¤§äº0")
    valid.Required(title, "title").Message("æ ‡é¢˜ä¸èƒ½ä¸ºç©º")
    valid.Required(desc, "desc").Message("ç®€è¿°ä¸èƒ½ä¸ºç©º")
    valid.Required(content, "content").Message("å†…å®¹ä¸èƒ½ä¸ºç©º")
    valid.Required(createdBy, "created_by").Message("åˆ›å»ºäººä¸èƒ½ä¸ºç©º")
    valid.Range(state, 0, 1, "state").Message("çŠ¶æ€åªå…è®¸0æˆ–1")

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        if models.ExistTagByID(tagId) {
            data := make(map[string]interface {})
            data["tag_id"] = tagId
            data["title"] = title
            data["desc"] = desc
            data["content"] = content
            data["created_by"] = createdBy
            data["state"] = state

            models.AddArticle(data)
            code = e.SUCCESS
        } else {
            code = e.ERROR_NOT_EXIST_TAG
        }
    } else {
        for _, err := range valid.Errors {
            log.Printf("err.key: %s, err.message: %s", err.Key, err.Message)
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : make(map[string]interface{}),
    })
}

//ä¿®æ”¹æ–‡ç« 
func EditArticle(c *gin.Context) {
    valid := validation.Validation{}

    id := com.StrTo(c.Param("id")).MustInt()
    tagId := com.StrTo(c.Query("tag_id")).MustInt()
    title := c.Query("title")
    desc := c.Query("desc")
    content := c.Query("content")
    modifiedBy := c.Query("modified_by")

    var state int = -1
    if arg := c.Query("state"); arg != "" {
        state = com.StrTo(arg).MustInt()
        valid.Range(state, 0, 1, "state").Message("çŠ¶æ€åªå…è®¸0æˆ–1")
    }

    valid.Min(id, 1, "id").Message("IDå¿…é¡»å¤§äº0")
    valid.MaxSize(title, 100, "title").Message("æ ‡é¢˜æœ€é•¿ä¸º100å­—ç¬¦")
    valid.MaxSize(desc, 255, "desc").Message("ç®€è¿°æœ€é•¿ä¸º255å­—ç¬¦")
    valid.MaxSize(content, 65535, "content").Message("å†…å®¹æœ€é•¿ä¸º65535å­—ç¬¦")
    valid.Required(modifiedBy, "modified_by").Message("ä¿®æ”¹äººä¸èƒ½ä¸ºç©º")
    valid.MaxSize(modifiedBy, 100, "modified_by").Message("ä¿®æ”¹äººæœ€é•¿ä¸º100å­—ç¬¦")

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        if models.ExistArticleByID(id) {
            if models.ExistTagByID(tagId) {
                data := make(map[string]interface {})
                if tagId > 0 {
                    data["tag_id"] = tagId
                }
                if title != "" {
                    data["title"] = title
                }
                if desc != "" {
                    data["desc"] = desc
                }
                if content != "" {
                    data["content"] = content
                }

                data["modified_by"] = modifiedBy

                models.EditArticle(id, data)
                code = e.SUCCESS
            } else {
                code = e.ERROR_NOT_EXIST_TAG
            }
        } else {
            code = e.ERROR_NOT_EXIST_ARTICLE
        }
    } else {
        for _, err := range valid.Errors {
            log.Printf("err.key: %s, err.message: %s", err.Key, err.Message)
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : make(map[string]string),
    })
}

//åˆ é™¤æ–‡ç« 
func DeleteArticle(c *gin.Context) {
    id := com.StrTo(c.Param("id")).MustInt()

    valid := validation.Validation{}
    valid.Min(id, 1, "id").Message("IDå¿…é¡»å¤§äº0")

    code := e.INVALID_PARAMS
    if ! valid.HasErrors() {
        if models.ExistArticleByID(id) {
            models.DeleteArticle(id)
            code = e.SUCCESS
        } else {
            code = e.ERROR_NOT_EXIST_ARTICLE
        }
    } else {
        for _, err := range valid.Errors {
            log.Printf("err.key: %s, err.message: %s", err.Key, err.Message)
        }
    }

    c.JSON(http.StatusOK, gin.H{
        "code" : code,
        "msg" : e.GetMsg(code),
        "data" : make(map[string]string),
    })
}
```

# æ•´ç†ä¸€æ³¢ä»£ç 
> ä¸‹é¢çš„ä¸œè¥¿ï¼Œæˆ‘è®²ä¸ä¼šä¸€æ¨¡ä¸€æ ·å®‰è£… ç…é±¼ å¤§ç¥çš„æ–‡ç« å»å†™ï¼Œæˆ‘å°†ä»¥è‡ªå·±çš„ç†è§£ä¸ºä¾æ®ï¼Œå†™ä¸‹é¢çš„å†…å®¹ï¼Œå¦‚æœ‰ä¸å¯¹çš„å¯¹æ–¹ï¼Œå¤§å®¶å¤šå¤šç†è§£å’ŒåŒ…æ¶µ
>

## ä¼˜åŒ–é…ç½®ç»“æ„
ç°åœ¨ä¸ºæ­¢ ï¼Œæˆ‘ä»¬ä»£ç ä¸­çš„è®¸å¤špkg éƒ½ä¸Šç›´æ¥ å¼•å…¥çš„ï¼Œä¸”éƒ½æ˜¯ç›´æ¥ç”¨çš„ini é…ç½®ã€‚

1. æ˜ å°„ç»“æ„ä½“ï¼Œä½¿ç”¨MapTo è®¾ç½®é…ç½®å‚æ•°
2. æŠŠå‚æ•°éƒ½ç®¡ç†åˆ°pkg/settingä¸­å»

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">åœ¨ Go ä¸­ï¼Œå½“å­˜åœ¨å¤šä¸ª init å‡½æ•°æ—¶ï¼Œæ‰§è¡Œé¡ºåºä¸ºï¼š</font>

+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ç›¸åŒåŒ…ä¸‹çš„ init å‡½æ•°ï¼šæŒ‰ç…§æºæ–‡ä»¶ç¼–è¯‘é¡ºåºå†³å®šæ‰§è¡Œé¡ºåºï¼ˆé»˜è®¤æŒ‰æ–‡ä»¶åæ’åºï¼‰</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ä¸åŒåŒ…ä¸‹çš„ init å‡½æ•°ï¼šæŒ‰ç…§åŒ…å¯¼å…¥çš„ä¾èµ–å…³ç³»å†³å®šå…ˆåé¡ºåº</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ‰€ä»¥è¦é¿å…å¤š init çš„æƒ…å†µï¼Œ</font>**<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">å°½é‡ç”±ç¨‹åºæŠŠæ§åˆå§‹åŒ–çš„å…ˆåé¡ºåº</font>**

 	å…ˆæŠŠé…ç½®é¡¹æå®šï¼Œä½¿ç”¨ å¤§é©¼å³°

```properties

[app]
PageSize = 10
JwtSecret = 23347$040412

RuntimeRootPath = runtime/

PrefixUrl = http://127.0.0.1:8000
ImageSavePath = upload/images/
ExportSavePath = export/
QrCodeSavePath = qrcode/
LogSavePath = logs/
FontSavePath = fonts/

# MB
ImageMaxSize = 5
ImageAllowExts = .jpg,.jpeg,.png

LogSaveName = log
LogFileExt = log
TimeFormat = 20060102

[server]
#debug or release
RunMode = debug
HttpPort = 8000
ReadTimeout = 60
WriteTimeout = 60

[database]
Type = mysql
User = root
Password = rootroot
Host = 192.168.1.5:3306
Name = go_logs
TablePrefix = blog_

[redis]
Host = 192.168.1.5:6379
Password =
MaxIdle = 30
MaxActive = 30
IdleTimeout = 200


```

```go
package setting

import (
	"log"
	"time"

	"github.com/go-ini/ini"
)

// 1.  ç¼–å†™ä¸é…ç½®é¡¹ä¿æŒä¸€è‡´çš„ç»“æ„ä½“ï¼ˆAppã€Serverã€Databaseï¼Œ Redisï¼‰
// 2. ä½¿ç”¨ MapTo å°†é…ç½®é¡¹æ˜ å°„åˆ°ç»“æ„ä½“ä¸Š å…·ä½“ç»“æ„ä½“çš„ç±»å‹æ˜¯æ€ä¹ˆæ ·å­çš„éœ€è¦çœ‹ä½ è‡ªå·±çš„ä½¿ç”¨åœºæ™¯è€Œå®š
// 3. å¯¹ä¸€äº›éœ€ç‰¹æ®Šè®¾ç½®çš„é…ç½®é¡¹è¿›è¡Œå†èµ‹å€¼

type App struct {
	JwtSecret       string // ä¸‹é¢çš„ä¸€äº›å­—æ®µ ä½ ç°åœ¨å¯èƒ½æ˜¯ä¸éœ€è¦çš„ï¼Œæˆ‘ä»¬å…ˆé…ç½®åœ¨è¿™é‡Œï¼Œ
    // åé¢ä½ ä¼šä½¿ç”¨å®ƒçš„
	PageSize        int
	RuntimeRootPath string

	PrefixUrl      string
	ImageSavePath  string
	ImageMaxSize   int
	ImageAllowExts []string
	FontSavePath   string

	ExportSavePath string
	QrCodeSavePath string
	LogSavePath    string
	LogSaveName    string
	LogFileExt     string
	TimeFormat     string
}

//âš ï¸ ä¸ºå•¥ä½¿ç”¨æŒ‡é’ˆ 
// åœ¨ MapTo ä¸­ typ.Kind() == reflect.Ptr çº¦æŸäº†å¿…é¡»ä½¿ç”¨æŒ‡é’ˆï¼Œ
// å¦åˆ™ä¼šè¿”å› cannot map to non-pointer struct çš„é”™è¯¯ã€‚è¿™ä¸ªæ˜¯è¡¨é¢åŸå› 

// æ›´å¾€å†…æ¢ç©¶ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ field.Set çš„åŸå› ï¼Œ
// å½“æ‰§è¡Œ val := reflect.ValueOf(v) ï¼Œå‡½æ•°é€šè¿‡ä¼ é€’ v æ‹·è´åˆ›å»ºäº† valï¼Œgoä¸­ä¼ é€’çš„æ˜¯å€¼çš„æ‹·è´
// ä½†æ˜¯ val çš„æ”¹å˜å¹¶ä¸èƒ½æ›´æ”¹åŸå§‹çš„ vï¼Œè¦æƒ³ val çš„æ›´æ”¹èƒ½ä½œç”¨åˆ° vï¼Œåˆ™å¿…é¡»ä¼ é€’ v çš„åœ°å€

var AppSetting = &App{}

type Server struct {
	RunMode      string
	HttpPort     int
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
}

var ServerSetting = &Server{}

type Database struct {
	Type        string
	User        string
	Password    string
	Host        string
	Name        string
	TablePrefix string
}

var DatabaseSetting = &Database{}

type Redis struct {
	Host        string
	Password    string
	MaxIdle     int
	MaxActive   int
	IdleTimeout time.Duration
}

var RedisSetting = &Redis{}

// å¼€å§‹æ‰§è¡Œ ä¸»è¦çš„æ–‡æ¡£ä¾æ®å°±æ˜¯ go-ini è¿™ä¸ªåŒ…
func Setup() {
	Cfg, err := ini.Load("conf/app.ini")
	if err != nil {
		log.Fatalf("Fail to parse 'conf/app.ini': %v", err)
	}

	err = Cfg.Section("app").MapTo(AppSetting)
	if err != nil {
		log.Fatalf("Cfg.MapTo AppSetting err: %v", err)
	}

	AppSetting.ImageMaxSize = AppSetting.ImageMaxSize * 1024 * 1024

	err = Cfg.Section("server").MapTo(ServerSetting)
	if err != nil {
		log.Fatalf("Cfg.MapTo ServerSetting err: %v", err)
	}

	ServerSetting.ReadTimeout = ServerSetting.ReadTimeout * time.Second // å¯¹äºtimeç±»å‹çš„éœ€è¦ * ä¸€ä¸ªé‡ å®Œæˆç±»å‹è½¬åŒ–
	ServerSetting.WriteTimeout = ServerSetting.WriteTimeout * time.Second

	err = Cfg.Section("database").MapTo(DatabaseSetting)
	if err != nil {
		log.Fatalf("Cfg.MapTo DatabaseSetting err: %v", err)
	}

	err = Cfg.Section("redis").MapTo(RedisSetting)
	if err != nil {
		log.Fatalf("Cfg.MapTo RedisSetting err: %v", err)
	}
	RedisSetting.IdleTimeout = RedisSetting.IdleTimeout * time.Second
}

```

ä¸‹é¢æ˜¯è¿™ä¸ªsetting åœ¨mianä¸­å¼•å…¥

```go
func main() {
	// ä¸ºäº†æ§åˆ¶ç¨‹åºçš„åŠ è½½çš„å…ˆåé¡ºåºï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨goä¸­è‡ªå¸¦çš„initå‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦è®¤ä¸ºçš„è·å–åˆ°æ§åˆ¶æƒ
	// setting\modeels\loggin\greeidsæ¨¡å—éƒ½åˆå§‹åŒ–æ‰§è¡Œä¸€é
	setting.Setup()
	models.Setup() // modle ä¹Ÿéœ€è¦è¿™æ ·åšï¼Œ
}
```

## Modelä¼˜åŒ–
å›é¡¾åŸæ¥çš„ä»£ç ï¼Œæˆ‘ä»¬ä¸éš¾å‘ç°ï¼Œdb çš„æ“ä½œéƒ½å†™åœ¨modelä¸­ã€‚å®ƒåº”è¯¥ä¿å­˜æ›´åŠ çº¯ç²¹ï¼Œä»Modelä¸‹åˆ€ï¼Œç®€åŒ–é‡Œé¢çš„hookï¼Œå®ƒå¯ä»¥è¢«ä¸¢åˆ°å…¨å±€å»ï¼Œå¹¶ä¸”æ”¹é€  å…¥å£ï¼Œä¸éœ€è¦init å‡½æ•°ï¼ŒBeforeCreate å’ŒBeforeUpdateä¹Ÿä¸è¦æ”¾åˆ°æ¯ä¸ªçš„å•ç‹¬çš„modelä¸­å»äº†ï¼Œç›´æ¥åœ¨å…¨å±€modelä¸­åŠ ä¸€ä¸ª è‡ªå®šä¹‰çš„callback ä»¥ä¾¿äºå®Œæˆæ›´å¤šçš„å·¥ä½œ

```go
package models

import (
	"fmt"
	"log"
	"time"

	"github.com/BM-laoli/go-gin-example/pkg/setting"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

var db *gorm.DB

type Model struct {
	ID         int `gorm:"primary_key" json:"id"`
	CreatedOn  int `json:"created_on"`
	ModifiedOn int `json:"modified_on"`
	DeletedOn  int `json:"deleted_on"`
}

// åˆå§‹åŒ– æ•°æ®åº“è¿æ¥
func Setup() {
	var (
		err error
	)

	// æ‰“å¼€è¿æ¥
	db, err = gorm.Open(setting.DatabaseSetting.Type, fmt.Sprintf("%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local",
		setting.DatabaseSetting.User,
		setting.DatabaseSetting.Password,
		setting.DatabaseSetting.Host,
		setting.DatabaseSetting.Name))

	if err != nil {
        // åšäº›ä»€ä¹ˆ
	}

	// è·å–æ•°æ®åº“åè¿æ¥
	gorm.DefaultTableNameHandler = func(db *gorm.DB, defaultTableName string) string {
		return setting.DatabaseSetting.TablePrefix + defaultTableName
	}

	// æ³¨å†Œå›è°ƒ åˆ›å»ºæ—¶ ä¿®æ”¹æ—¶ åˆ é™¤æ—¶
	db.Callback().Create().Replace("gorm:update_time_stamp", updateTimeStampForCreateCallback)
	db.Callback().Update().Replace("gorm:update_time_stamp", updateTimeStampForUpdateCallback)
	db.Callback().Delete().Replace("gorm:delete", deleteCallback)

	// é…ç½®æ˜¯å¦å¯ä»¥å†™å…¥æç¤º
	// æ•°æ®åº“ä¸­åªæœ‰ è¡¨ï¼Œæ²¡æœ‰db.SingularTable(true)è®¾ç½®ï¼Œç›¸åŒçš„æ·»åŠ æ•°æ®çš„æ“ä½œéƒ½ä¼šå¤±è´¥ï¼Œæç¤ºusersè¡¨ä¸å­˜åœ¨
	// LogModeæ˜¯å®šä¹‰æ—¥å¿—è®°å½•çš„å¯ç”¨æ¨¡å¼çš„ç±»å‹ï¼Œè¿™äº›æ¨¡å¼ä¼šå½±å“æ—¥å¿—æ¶ˆæ¯å¼€å§‹å †ç§¯æ—¶å¦‚ä½•å¤„ç†æ—¥å¿—ã€‚
	db.SingularTable(true)
	db.LogMode(true)

	// è®¾ç½®è¿æ¥é™åˆ¶ æ¯”å¦‚
	db.DB().SetMaxIdleConns(10)
	db.DB().SetMaxOpenConns(100)
}

// å…³é—­è¿æ¥
func CloseDB() {
	defer db.Close()
}

// å„ç§å›è°ƒ
// updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating åˆ›å»ºå­—æ®µçš„æ—¶å€™é™„åŠ å­—æ®µè¿›å…¥db
func updateTimeStampForCreateCallback(scope *gorm.Scope) {
	if !scope.HasError() {
		nowTime := time.Now().Unix()
		if createTimeField, ok := scope.FieldByName("CreatedOn"); ok {
			if createTimeField.IsBlank {
				createTimeField.Set(nowTime)
			}
		}

		if modifyTimeField, ok := scope.FieldByName("ModifiedOn"); ok {
			if modifyTimeField.IsBlank {
				modifyTimeField.Set(nowTime)
			}
		}
	}
}

// è¿™ä¸ªä¸œè¥¿æˆ‘ä»¬æš‚æ—¶å…ˆä¸äº†è§£ 
// updateTimeStampForUpdateCallback will set `ModifyTime` when updating // æ•°æ®æ›´æ–°çš„æ—¶å€™æ·»åŠ åˆ°æ•°æ®åº“ä¸­å»
func updateTimeStampForUpdateCallback(scope *gorm.Scope) {
	if _, ok := scope.Get("gorm:update_column"); !ok {
		scope.SetColumn("ModifiedOn", time.Now().Unix())
	}
}

// deleteCallback will set `DeletedOn` where deleting
func deleteCallback(scope *gorm.Scope) {
	if !scope.HasError() {
		var extraOption string
		if str, ok := scope.Get("gorm:delete_option"); ok {
			extraOption = fmt.Sprint(str)
		}

		deletedOnField, hasDeletedOnField := scope.FieldByName("DeletedOn")

		if !scope.Search.Unscoped && hasDeletedOnField {
			scope.Raw(fmt.Sprintf(
				"UPDATE %v SET %v=%v%v%v",
				scope.QuotedTableName(),
				scope.Quote(deletedOnField.DBName),
				scope.AddToVars(time.Now().Unix()),
				addExtraSpaceIfExist(scope.CombinedConditionSql()),
				addExtraSpaceIfExist(extraOption),
			)).Exec()
		} else {
			scope.Raw(fmt.Sprintf(
				"DELETE FROM %v%v%v",
				scope.QuotedTableName(),
				addExtraSpaceIfExist(scope.CombinedConditionSql()),
				addExtraSpaceIfExist(extraOption),
			)).Exec()
		}
	}
}

// è¿™ä¸ªæ–¹æ³•æœ‰ç‚¹ä¸¢å¤šä½™ å°±æ—¶çœ‹çœ‹string åŠ ä¸€ä¸ªç‰µåˆ¶ç©ºæ ¼ ä½œç”¨æ˜¯åç»­ ä¾æ®æ–‡ä»¶æ‰‹åŠ¨ä¿®æ”¹åº“çš„æ—¶å€™ä½¿ç”¨çš„
// addExtraSpaceIfExist adds a separator
func addExtraSpaceIfExist(str string) string {
	if str != "" {
		return " " + str
	}
	return ""
}

```

## Controllerï¼ŸServiceï¼Ÿ
åœ¨ç»å…¸çš„ JAVAæ¡†æ¶Spring ä¸­ï¼Œç»å¸¸ä¼šå‡ºç°ä¸‹é¢çš„ç¨‹åºç»“æ„ï¼ˆä¸‹é¢æ˜¯Nest çš„ä¸€ä¸ªé¡¹ç›®ç»“æ„ï¼‰

![](https://cdn.nlark.com/yuque/0/2023/png/1627571/1672741488821-97ad65ec-4b1f-4f4b-8c9f-b1541d6e8c64.png)

å®è·µè¯æ˜ï¼Œå®ƒç¡®å®å€¼å¾—æ¨æ•²ï¼Œè‡³å°‘å®ƒçš„åˆ†å±‚ç»“æ„ æ˜¯åˆç†ä¸”å¯å¤ç”¨ï¼Œä»¥åŠä¾¿äºç®¡ç†çš„ï¼Œæˆ‘ä»¬å€Ÿé‰´ä¸€äº›å®ƒçš„æ€æƒ³å§ï¼

ä»Serviceä¸‹åˆ€  è¯·å¿½ç•¥é‡Œé¢è¿˜æ²¡æœ‰å†™å¥½çš„ auth cache service æˆ‘ä»¬æ¥å…³æ³¨ tag å’Œ article ï¼Œåœ¨å†™service ä¹‹å‰æˆ‘ä»¬å…ˆæ•´ç†ä¸€æ³¢ ï¼Œæ¯ä¸ªçš„modle

```go
package models

import "github.com/jinzhu/gorm"

type Tag struct {
	Model

	Name       string `json:"name"`
	CreatedBy  string `json:"created_by"`
	ModifiedBy string `json:"modified_by"`
	State      int    `json:"state"`
}

// ExistTagByName checks if there is a tag with the same name
func ExistTagByName(name string) (bool, error) {
	var tag Tag
	err := db.Select("id").Where("name = ? AND deleted_on = ? ", name, 0).First(&tag).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return false, err
	}

	if tag.ID > 0 {
		return true, nil
	}

	return false, nil
}

// AddTag Add a Tag
func AddTag(name string, state int, createdBy string) error {
	tag := Tag{
		Name:      name,
		State:     state,
		CreatedBy: createdBy,
	}
	if err := db.Create(&tag).Error; err != nil {
		return err
	}

	return nil
}

// GetTags gets a list of tags based on paging and constraints
func GetTags(pageNum int, pageSize int, maps interface{}) ([]Tag, error) {
	var (
		tags []Tag
		err  error
	)

	if pageSize > 0 && pageNum > 0 {
		err = db.Where(maps).Find(&tags).Offset(pageNum).Limit(pageSize).Error
	} else {
		err = db.Where(maps).Find(&tags).Error
	}

	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}

	return tags, nil
}

// GetTagTotal counts the total number of tags based on the constraint
func GetTagTotal(maps interface{}) (int, error) {
	var count int
	if err := db.Model(&Tag{}).Where(maps).Count(&count).Error; err != nil {
		return 0, err
	}

	return count, nil
}

// ExistTagByID determines whether a Tag exists based on the ID
func ExistTagByID(id int) (bool, error) {
	var tag Tag
	err := db.Select("id").Where("id = ? AND deleted_on = ? ", id, 0).First(&tag).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return false, err
	}
	if tag.ID > 0 {
		return true, nil
	}

	return false, nil
}

// DeleteTag delete a tag
func DeleteTag(id int) error {
	if err := db.Where("id = ?", id).Delete(&Tag{}).Error; err != nil {
		return err
	}

	return nil
}

// EditTag modify a single tag
func EditTag(id int, data interface{}) error {
	if err := db.Model(&Tag{}).Where("id = ? AND deleted_on = ? ", id, 0).Updates(data).Error; err != nil {
		return err
	}

	return nil
}

// CleanAllTag clear all tag
func CleanAllTag() (bool, error) {
	if err := db.Unscoped().Where("deleted_on != ? ", 0).Delete(&Tag{}).Error; err != nil {
		return false, err
	}

	return true, nil
}

```

```go
package models

import "github.com/jinzhu/gorm"

//  ------------------------------------------------å‡†å¤‡å·¥ä½œå®šä¹‰æ¨¡å‹ å’Œcallback
type Article struct {
	Model

	TagID int `json:"tag_id" gorm:"index"` //å£°æ˜ è¿™ä¸ªå­—æ®µæ˜¯ ç´¢å¼• å¤–é”®  ï¼ˆâš ï¸ï¼šå¦‚æœä½ æƒ³å…³è” é‚£ä¹ˆå¤–é”® å’Œ struct éƒ½è¦æœ‰ï¼‰
	Tag   Tag `json:"tag"`                 //  å†…åµŒçš„model

	Title         string `json:"title"`
	Desc          string `json:"desc"`
	Content       string `json:"content"`
	CreatedBy     string `json:"created_by"`
	ModifiedBy    string `json:"modified_by"`
	State         int    `json:"state"`
	CoverImageUrl string `json:"cover_image_url"`
}

//  ------------------------------------------------ æ­£å¼å¼€å§‹é€»è¾‘

// åˆ¤æ–­æœ‰æ²¡æœ‰è¿™ä¸ªæ–‡ç« 
func ExistArticleByID(id int) bool {
	var article Article
	db.Select("id").Where("id = ?", id).First(&article)

	if article.ID > 0 {
		return true
	}

	return false
}

// è·å–LIstæ€»æ•°
func GetArticleTotal(maps interface{}) (count int) {
	db.Model(&Article{}).Where(maps).Count(&count)

	return
}

// è·å–æ–‡ç« List
// func GetArticles(pageNum int, pageSize int, maps interface{}) (articles []Article) {
// 	db.Preload("Tag").Where(maps).Offset(pageNum).Limit(pageSize).Find(&articles)
// 	// æ³¨æ„è¿™ä¸ª Preload
// 	// å®ƒ æ˜¯ä¸€ä¸ªé¢„åŠ è½½å™¨ å°±æ‰§è¡Œä¸¤æ¡SQLï¼Œä¸Šé¢çš„ğŸ‘†çš„ormç¿»è¯‘è¿‡æ¥å°±æ˜¯
// 	// SELECT * FROM blog_articles;    SELECT * FROM blog_tag WHERE id IN (1,2,3,4);
// 	// åœ¨gormä¸­åšå…³è”æŸ¥è¯¢ä¸»è¦æ˜¯ä¸¤ç§æ–¹å¼
// 	// 1. gorm çš„Join 2. å¾ªç¯çš„Related
// 	return
// }
// GetArticles gets a list of articles based on paging constraints
func GetArticles(pageNum int, pageSize int, maps interface{}) ([]*Article, error) {
	var articles []*Article
	err := db.Preload("Tag").Where(maps).Offset(pageNum).Limit(pageSize).Find(&articles).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}

	return articles, nil
}

func GetArticle(id int) (*Article, error) {
	var article Article
	err := db.Where("id = ? AND deleted_on = ? ", id, 0).First(&article).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}

	err = db.Model(&article).Related(&article.Tag).Error
	if err != nil && err != gorm.ErrRecordNotFound {
		return nil, err
	}

	return &article, nil
}

// è¿™é‡Œæœ‰ä¸€ä¸ªç©ºæ¥å£ ç±»ä¼¼äºany
func EditArticle(id int, data interface{}) error {
	if err := db.Model(&Article{}).Where("id = ? AND deleted_on = ? ", id, 0).Updates(data).Error; err != nil {
		return err
	}

	return nil

}

func AddArticle(data map[string]interface{}) error {
	article := &Article{
		TagID: data["tag_id"].(int),
		// æˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªè¯­æ³• ï¼Œå®é™…ä¸Šå®ƒæƒ³è¡¨è¾¾çš„æ˜¯ï¼š
		// 1. V.( I ) æ–­è¨€ ï¼ŒI è¡¨ç¤ºæ¥å£interface Vè¡¨ç¤ºä¸€ä¸ªå€Ÿå£å€¼ï¼Œ V.( I ) è¿™å¥è¯çš„æ„æ€æ˜¯ çœ‹çœ‹ æ¥å£çš„å€¼ æ˜¯å¦ä¸ºæŸä¸€ä¸ªç±»å‹
		// 2. ç»“åˆä¸Šè¿°çš„ç†è§£å°±æ˜¯ï¼š çœ‹çœ‹ ç±»å‹dataä¸­çš„Tag_idçš„å€¼ æ˜¯å¦æ˜¯int
		Title:         data["title"].(string),
		Desc:          data["desc"].(string),
		Content:       data["content"].(string),
		CreatedBy:     data["created_by"].(string),
		State:         data["state"].(int),
		CoverImageUrl: data["cover_image_url"].(string),
	}

	if err := db.Create(&article).Error; err != nil {
		return err
	}
	return nil
}

// DeleteArticle delete a single article
func DeleteArticle(id int) error {
	if err := db.Where("id = ?", id).Delete(Article{}).Error; err != nil {
		return err
	}

	return nil
}

// å®šæ—¶job
func CleanAllArticle() bool {
	db.Unscoped().Where("deleted_on != ? ", 0).Delete(&Article{})

	return true
}

```

![](https://cdn.nlark.com/yuque/0/2023/png/1627571/1672724846880-c38c2e24-d35b-40f8-acdd-eec1e367a963.png)

```go
// æˆ‘ä»¬åœ¨service ï¼Œå…³æ³¨ç‚¹åœ¨ä¸šåŠ¡ç»„åˆï¼Œå¾ˆå¤šçš„ä¸šåŠ¡æµå’Œä¸€äº›ç‰¹æ®Šçš„é€»è¾‘éƒ½å¯ä»¥æ”¾åˆ°è¿™é‡Œæ¥åš

// å…ˆå‡†å¤‡æˆ‘ä»¬çš„tagService
package tag_service

import (
	"encoding/json"
	"io"
	"time"
	"github.com/BM-laoli/go-gin-example/models"
)

// è¿™ä¸œè¥¿å’Œ modelä¸­çš„ä¸ä¸€æ ·ï¼Œmodelä¸­ï¼Œæ›´å€¾å‘äº æ•°æ® entities
// è¿™é‡Œçš„ Tag æ›´å€¾å‘äº service å’Œ controller ä¹‹é—´çš„åè®®ï¼Œä¹Ÿå°±æ˜¯dto
type Tag struct {
	ID         int
	Name       string
	CreatedBy  string
	ModifiedBy string
	State      int

	PageNum  int
	PageSize int
}

func (t *Tag) ExistByName() (bool, error) {
	return models.ExistTagByName(t.Name)
}

func (t *Tag) ExistByID() (bool, error) {
	return models.ExistTagByID(t.ID)
}

func (t *Tag) Add() error {
	return models.AddTag(t.Name, t.State, t.CreatedBy)
}

//  æ‰§è¡Œä¿®æ”¹
func (t *Tag) Edit() error {
	data := make(map[string]interface{})
	data["modified_by"] = t.ModifiedBy
	data["name"] = t.Name
	if t.State >= 0 {
		data["state"] = t.State
	}

	return models.EditTag(t.ID, data)
}

func (t *Tag) Delete() error {
	return models.DeleteTag(t.ID)
}

func (t *Tag) Count() (int, error) {
	return models.GetTagTotal(t.getMaps())
}


func (t *Tag) GetAll() ([]models.Tag, error) {
	var (
		tags, cacheTags []models.Tag
	)
    
	tags, err := models.GetTags(t.PageNum, t.PageSize, t.getMaps())
	if err != nil {
		return nil, err
	}

    return tags, nil
}

// ä¸»è¦çœ‹æ˜¯å¦æ˜¯ å±äº â€œå·²ç»è½¯åˆ é™¤â€
func (t *Tag) getMaps() map[string]interface{} {
	maps := make(map[string]interface{})
	maps["deleted_on"] = 0

	if t.Name != "" {
		maps["name"] = t.Name
	}
	if t.State >= 0 {
		maps["state"] = t.State
	}

	return maps
}

// å†è€Œå¯çœ‹article service
package article_service

import (
	"encoding/json"

	"github.com/BM-laoli/go-gin-example/models"
	"github.com/BM-laoli/go-gin-example/pkg/gredis"
	"github.com/BM-laoli/go-gin-example/pkg/logging"
	"github.com/BM-laoli/go-gin-example/service/cache_service"
)

// å®šä¹‰ article ç»“æ„ç”¨æ¥å­˜query æ•°æ®
type Article struct {
	ID            int
	TagID         int
	Title         string
	Desc          string
	Content       string
	CoverImageUrl string
	State         int
	CreatedBy     string
	ModifiedBy    string

	PageNum  int
	PageSize int
}

func (a *Article) Add() error {
	article := map[string]interface{}{
		"tag_id":          a.TagID,
		"title":           a.Title,
		"desc":            a.Desc,
		"content":         a.Content,
		"created_by":      a.CreatedBy,
		"cover_image_url": a.CoverImageUrl,
		"state":           a.State,
	}

    // å®šä¹‰ä¸€ä¸ª map ï¼ˆå®é™…ä¸Š æˆ‘ä¸ªäººè§‚ç‚¹ map å’Œ strut ç±»ä¼¼ jsä¸­çš„object ï¼‰

	if err := models.AddArticle(article); err != nil {
		return err
	}

	return nil
}

func (a *Article) Edit() error {
	return models.EditArticle(a.ID, map[string]interface{}{
		"tag_id":          a.TagID,
		"title":           a.Title,
		"desc":            a.Desc,
		"content":         a.Content,
		"cover_image_url": a.CoverImageUrl,
		"state":           a.State,
		"modified_by":     a.ModifiedBy,
	})
}

func (a *Article) Get() (*models.Article, error) {
	
	article, err := models.GetArticle(a.ID)
	if err != nil {
		return nil, err
	}

	return article, nil
}

func (a *Article) GetAll() ([]*models.Article, error) {
	var (
		articles []*models.Article
	)


	articles, err := models.GetArticles(a.PageNum, a.PageSize, a.getMaps())
	if err != nil {
		return nil, err
	}

	return articles, nil
}

func (a *Article) Delete() error {
	return models.DeleteArticle(a.ID)
}

func (a *Article) ExistByID() (bool, error) {
	return models.ExistArticleByID(a.ID), nil
}

func (a *Article) Count() (int, error) {
	return models.GetArticleTotal(a.getMaps()), nil
}

func (a *Article) getMaps() map[string]interface{} {
	maps := make(map[string]interface{})
	maps["deleted_on"] = 0
	if a.State != -1 {
		maps["state"] = a.State
	}
	if a.TagID != -1 {
		maps["tag_id"] = a.TagID
	}

	return maps
}



```

åœ¨å‰é¢çš„æ‹†åˆ†ä¸­ï¼Œæˆ‘ä»¬å¤šæ¬¡çœ‹åˆ°äº†è¿™æ ·çš„ä»£ç 

```go
type Article struct {
	ID            int
	TagID         int
	Title         string
	Desc          string
	Content       string
	CoverImageUrl string
	State         int
	CreatedBy     string
	ModifiedBy    string

	PageNum  int
	PageSize int
}

func (a *Article) getMaps() map[string]interface{} {
	maps := make(map[string]interface{})
	maps["deleted_on"] = 0
	if a.State != -1 {
		maps["state"] = a.State
	}
	if a.TagID != -1 {
		maps["tag_id"] = a.TagID
	}

	return maps
}

// Article structä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªåœ¨ service å’Œåœ¨ controller å±‚é€šç”¨çš„ è§£æç»“æ„ï¼Œ
// getMaps ä¸ºmodel sqlçš„æ‰§è¡Œï¼Œæä¾›äº†ä¸€äº›å‰ç½®è¿‡æ»¤é€»è¾‘

```

ä¸‹é¢æˆ‘ä»¬å°±èŠ±ç‚¹æ—¶é—´çœ‹çœ‹ï¼Œï¼› é¦–å…ˆæˆ‘ä»¬éœ€è¦çœ‹çœ‹ ç›®å‰æˆ‘ä»¬çš„ä» httpä¸Šå–å‚æ•°å’Œè§£æçš„ä»¥åŠè¿‡æ»¤çš„è¿‡ç¨‹ï¼Œ

å¦å¤–æˆ‘ä»¬è¿˜æ²¡æœ‰æåˆ°çš„ä¸€ç‚¹å°±æ˜¯ ï¼Œç»Ÿä¸€çš„è¿”å›æ ¼å¼ï¼Œè¿™ä¸ªç‚¹é€šè¿‡ä¸€ä¸ªå…¬å…±æ–¹æ³•æ¥åŒ…è£…è¿”å›

```go
// Response setting gin.JSON  ä¸ºgin.jsonè®¾ç½®è¿”æ ¼å¼ ç±»ä¼¼äºOOPä¸­çš„å¯¹ç±»æ–¹æ³•çš„é‡å†™
func (g *Gin) Response(httpCode, errCode int, data interface{}) {
	g.C.JSON(httpCode, Response{
		Code: errCode,
		Msg:  e.GetMsg(errCode),
		Data: data,
	})
	return
}
```

```go
// http è·å–å‚æ•°
type AddTagForm struct {
	Name      string `json:"name" valid:"Required;MaxSize(100)"`
	CreatedBy string `json:"created_by" valid:"Required;MaxSize(100)"`
	State     int    `json:"state" valid:"Range(0,1)"`
}
// è¿™ä¸œè¥¿ç”¨æ¥åšéªŒè¯ç”¨çš„ï¼Œå‰é¢æˆ‘ä»¬æåˆ°è¿‡ï¼Œä¸‹é¢æ˜¯å°±æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„éªŒè¯æ–¹å¼
func BindAndValidForJSON(c *gin.Context, json interface{}) (int, int) {
	err := c.BindJSON(json)
	if err != nil {
		return http.StatusBadRequest, e.INVALID_PARAMS
	}

	valid := validation.Validation{}
	check, err := valid.Valid(json)
	if err != nil {
		return http.StatusInternalServerError, e.ERROR
	}
	if !check {
		MarkErrors(valid.Errors)
		return http.StatusBadRequest, e.INVALID_PARAMS
	}

	return http.StatusOK, e.SUCCESS
}

// æˆ‘ä»¬å†™äº†ä¸€ä¸ª é€šç”¨çš„ è¿”å›å€¼çš„ æ ¼å¼åŒ–æ–¹æ³•
type Gin struct {
	C *gin.Context
}

type Response struct {
	Code int         `json:"code"`
	Msg  string      `json:"msg"`
	Data interface{} `json:"data"`
}

// Response setting gin.JSON  ä¸ºgin.jsonè®¾ç½®è¿”æ ¼å¼ ç±»ä¼¼äºOOPä¸­çš„å¯¹ç±»æ–¹æ³•çš„é‡å†™
func (g *Gin) Response(httpCode, errCode int, data interface{}) {
	g.C.JSON(httpCode, Response{
		Code: errCode,
		Msg:  e.GetMsg(errCode),
		Data: data,
	})
	return
}

// ä»¥ä¸Šçš„æ–¹æ³•ç»„åˆï¼Œå°±æœ‰äº†æˆ‘ä»¬çš„addTagçš„ä¸€ä¸ªè…¿çš„ controller é€»è¾‘ ï¼ˆæˆ–è€…è¯´routerå…·ä½“å–å€¼ä¼ é€’
åˆ°serviceçš„è¿‡ç¨‹ï¼‰
func AddTag(c *gin.Context) {
	var (
		appG = app.Gin{C: c}
		jsonForm AddTagForm
	)

	// éªŒè¯formè¡¨å•
	httpCode, errCode := app.BindAndValidForJSON(c, &jsonForm)
	if errCode != e.SUCCESS {
		appG.Response(httpCode, errCode, nil)
		return
	}

	tagService := tag_service.Tag{
		Name:      jsonForm.Name,
		CreatedBy: jsonForm.CreatedBy,
		State:     jsonForm.State,
	}
	exists, err := tagService.ExistByName()
	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR_EXIST_TAG_FAIL, nil)
		return
	}
	if exists {
		appG.Response(http.StatusOK, e.ERROR_EXIST_TAG, nil)
		return
	}

	err = tagService.Add()
	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR_ADD_TAG_FAIL, nil)
		return
	}

	appG.Response(http.StatusOK, e.SUCCESS, nil)
}

```

## è·¯ç”±å‚æ•°ï¼Ÿ
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç›®å‰è¿˜æ˜¯æœ‰éå¸¸çš„å¤š å–å€¼ï¼ˆä»HttpæŠ¥æ–‡æ¥çš„ï¼Œéƒ½ä¸æ˜¯ä¸€ç§æ­£è§„çš„æ–¹å¼ï¼‰ï¼Œæˆ‘ä»¬æ¥å¯¹ä»–ä»¬æ”¹é€ ä¸€ä¸‹ï¼Œæˆ‘ä»¬è¿™ä¸¾ä¾‹å­tag ç›¸å…³çš„å†…å®¹ï¼Œå…¶å®ƒçš„article ï¼Œè¿˜éœ€è¦å¤§å®¶è‡ªå·±å»æ”¹å“ˆã€‚

```go
// å®é™…ä¸Šï¼Œæˆ‘ä»¬æ³¨æ„è§‚å¯Ÿï¼Œå‰é¢æˆ‘ä»¬æåˆ°çš„ä»£ç 
func EditTag(c *gin.Context) {
	var (
		appG = app.Gin{C: c}
		form = EditTagForm{ID: com.StrTo(c.Param("id")).MustInt()}
	)

	httpCode, errCode := app.BindAndValid(c, &form) // ç”¨åˆ°äº†è¿™ä¸ªæ–¹æ³• è¿™ä¸ªæ–¹æ³•é‡Œå°±
    // åŒ…å«äº†å–å€¼ + æ•°æ®éªŒè¯ é€»è¾‘
    // æ³¨æ„è¿™é‡Œå…¶å®æ˜¯ä¸æ­£ç¡®çš„å†™æ³•ï¼Œæˆ‘ä»¬éœ€è¦ä»json bodyä¸­å–å€¼ï¼Œå¦‚ä½•ä»params ä¸­è·å– id
    // .....
}

func AddTag(c *gin.Context) {
	var (
		appG = app.Gin{C: c}
		jsonForm AddTagForm
	)
	
	httpCode, errCode := app.BindAndValidForJSON(c, &jsonForm)
    // è¿™é‡Œä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå–å€¼ + éªŒè¯
	if errCode != e.SUCCESS {
		appG.Response(httpCode, errCode, nil)
		return
	}

    // ...
}

// BindAndValid binds and validates data
func BindAndValid(c *gin.Context, form interface{}) (int, int) {
	err := c.Bind(form) // è¿™ä¸ªæ˜¯ä» ? params ä¸Šå–å€¼ è¿›è¡ŒéªŒè¯
	if err != nil {
		return http.StatusBadRequest, e.INVALID_PARAMS
	}

	valid := validation.Validation{}
	check, err := valid.Valid(form)
	if err != nil {
		return http.StatusInternalServerError, e.ERROR
	}
	if !check {
		MarkErrors(valid.Errors)
		return http.StatusBadRequest, e.INVALID_PARAMS
	}

	return http.StatusOK, e.SUCCESS
}

// BindAndValid binds and validates data
func BindAndValidForJSON(c *gin.Context, json interface{}) (int, int) {
	err := c.BindJSON(json) // è¿™é‡Œå°±ä»body ä¸­è¯»å– json æ•°æ®
	if err != nil {
		return http.StatusBadRequest, e.INVALID_PARAMS
	}

	valid := validation.Validation{}
	check, err := valid.Valid(json)
	if err != nil {
		return http.StatusInternalServerError, e.ERROR
	}
	if !check {
		MarkErrors(valid.Errors)
		return http.StatusBadRequest, e.INVALID_PARAMS
	}

	return http.StatusOK, e.SUCCESS
}
// å–ä¹‹å°±æ˜¯å¦‚æ­¤çš„ç®€å•ï¼Œæ›´å¤šçš„å–å€¼æ–¹æ³•åœ¨å‰é¢å·²ç»è¯¦ç»†çš„è¯´æ˜è¿‡äº†
```

# è‡ªå®šä¹‰<font style="color:rgb(51, 51, 51);">GORM Callbacks & è½¯åˆ é™¤</font>
ç»†å¿ƒçš„æœ‹å‹ä»¬ä¹Ÿè®¸å‘ç°äº†ï¼Œæˆ‘ä»¬å‰é¢æ²¡æœ‰ä½¿ç”¨ BeforeCreate ï¼Œè¿™ç§callbackäº†ï¼Œå› ä¸ºå®ƒçœ‹èµ·æ¥æ˜¯ç»‘å®šåˆ°äº†ç‰¹å®šçš„modelä¸Šï¼Œå¦‚æœæœ‰100+çš„model æˆ‘ä»¬å¹¶ä¸å¯èƒ½æ¯ä¸€ä¸ªéƒ½åŠ  ä¸€ä¸ªBeforeCreateç±»ä¼¼çš„hookã€‚åœ¨gormä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°è‡ªå®šä¹‰çš„ å…¨å±€hookã€‚

æ•…æˆ‘ä»¬éœ€è¦ä¿®æ”¹å®ƒï¼Œå‰æ–‡è™½ç„¶å·²ç»å†™å¥½å•¦ï¼Œä½†æ˜¯æˆ‘ä»¬æœ¬å°èŠ‚æ¥æè¿°ä¸€ä¸‹ä¸ºä»€ä¹ˆè¿™ä¹ˆåšï¼ŒåŸç†æ˜¯ä»€ä¹ˆ.

åœ¨åšä¸‹é¢çš„æ“ä½œä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ç»™ æ•´ä½“çš„model é€šç”¨ç»“æ„ ä¸ŠåŠ ä¸€äº›é€šç”¨çš„å­—æ®µ DeletedOn è¿™ç§ï¼Œè¿™æ ·ä½ è‡ªå·±çš„model å°±ä¸éœ€è¦å¤šæ¬¡å®šä¹‰å•¦ï¼Œå¦‚æœæœ‰ éœ€è¦ç›´æ¥ å¼•å…¥å°±å¯ä»¥å…±äº«é‡Œé¢çš„å­—æ®µå•¦

```go
type Model struct {
    ID int `gorm:"primary_key" json:"id"`
    CreatedOn int `json:"created_on"`
    ModifiedOn int `json:"modified_on"`
    DeletedOn int `json:"deleted_on"`
}

type Tag struct {
	Model

	Name       string `json:"name"`
	CreatedBy  string `json:"created_by"`
	ModifiedBy string `json:"modified_by"`
	State      int    `json:"state"`
}
// ç­‰ä»·
type Tag struct {
    ID int `gorm:"primary_key" json:"id"`
    CreatedOn int `json:"created_on"`
    ModifiedOn int `json:"modified_on"`
    DeletedOn int `json:"deleted_on"`
    
	Name       string `json:"name"`
	CreatedBy  string `json:"created_by"`
	ModifiedBy string `json:"modified_by"`
	State      int    `json:"state"`
}
```

1. æˆ‘ä»¬éœ€è¦æ³¨å†Œæˆ‘ä»¬è‡ªå®šä¹‰çš„cb

```go
// updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating åˆ›å»ºå­—æ®µçš„æ—¶å€™é™„åŠ å­—æ®µè¿›å…¥db
func updateTimeStampForCreateCallback(scope *gorm.Scope) {
	if !scope.HasError() {
		nowTime := time.Now().Unix()
		if createTimeField, ok := scope.FieldByName("CreatedOn"); ok {
			if createTimeField.IsBlank {
				createTimeField.Set(nowTime)
			}
		}

		if modifyTimeField, ok := scope.FieldByName("ModifiedOn"); ok {
			if modifyTimeField.IsBlank {
				modifyTimeField.Set(nowTime)
			}
		}
	}
}

// updateTimeStampForUpdateCallback will set `ModifyTime` when updating // æ•°æ®æ›´æ–°çš„æ—¶å€™æ·»åŠ åˆ°æ•°æ®åº“ä¸­å»
func updateTimeStampForUpdateCallback(scope *gorm.Scope) {
	if _, ok := scope.Get("gorm:update_column"); !ok {
		scope.SetColumn("ModifiedOn", time.Now().Unix())
	}
}

// ç”¨åˆ°çš„æºç  å’Œç®€å•è§£æ

func (scope *Scope) FieldByName(name string) (field *Field, ok bool) {
	// +++++
	for _, field := range scope.Fields() {
		if field.Name == name || field.DBName == name {
			return field, true
		}
		if field.DBName == dbName {
			mostMatchedField = field
		}
	}
    // +++++
}
// é€šè¿‡ Fields è·å–æ‰€æœ‰å­—æ®µï¼Œç„¶ååˆ¤æ–­æ˜¯å¦å…·å¤‡å½“å‰å­—æ®µ
// Set ç”¨æ¥ç»™ å­—æ®µè®¾ç½®å€¼ ï¼Œå‚æ•°ä¸º interface{}
// scope.Get(...) æ ¹æ®å…¥å‚è·å–è®¾ç½®äº†å­—é¢å€¼çš„å‚æ•°ï¼Œä¾‹å¦‚æœ¬æ–‡ä¸­æ˜¯ gorm:update_column ï¼Œå®ƒä¼šå»æŸ¥æ‰¾å«è¿™ä¸ªå­—é¢å€¼çš„å­—æ®µå±æ€§
// scope.SetColumn(...) å‡è®¾æ²¡æœ‰æŒ‡å®š update_column çš„å­—æ®µï¼Œæˆ‘ä»¬é»˜è®¤åœ¨æ›´æ–°å›è°ƒè®¾ç½® ModifiedOn çš„å€¼


```

2. ç„¶åæŒ‚å›å»

```go
//++++
// æ³¨å†Œå›è°ƒ åˆ›å»ºæ—¶ ä¿®æ”¹æ—¶ åˆ é™¤æ—¶
db.Callback().Create().Replace("gorm:update_time_stamp", updateTimeStampForCreateCallback)
db.Callback().Update().Replace("gorm:update_time_stamp", updateTimeStampForUpdateCallback)
```

å¤„ç†å®Œ è¿™ä¸ªæ¯æ‰ä¹‹åï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ï¼Œåšä¸€ä¸ªè½¯åˆ é™¤é€»è¾‘ï¼Œå®é™…çš„ä¸šåŠ¡ä¸­ï¼Œé€šå¸¸éƒ½ä¼šåŒºåˆ†è½¯åˆ é™¤å’Œç¡¬åˆ é™¤ä¸¤ç§.

```go

// deleteCallback will set `DeletedOn` where deleting
func deleteCallback(scope *gorm.Scope) {
	if !scope.HasError() {
		var extraOption string
        // å…ˆæ£€æŸ¥æ˜¯å¦æ‰‹åŠ¨è®¾ç½®å•¦ delete_option
		if str, ok := scope.Get("gorm:delete_option"); ok {
			extraOption = fmt.Sprint(str)
		}
        // è·å–è¿™ä¸ªå­—æ®µï¼Œå¦‚æœå­˜åœ¨ è¿™ä¸ªå­—æ®µ é‚£ä¹ˆ åœ¨update è½¯åˆ é™¤ï¼Œå¦åˆ™ç¡¬åˆ é™¤
        // æ„æ€å°±æ˜¯ï¼šåªæœ‰ä½ çš„modelï¼Œtab ä¸­å­˜åœ¨è¿™ä¸ªå­—æ®µ æ‰ä¼šå»è½¯åˆ é™¤ï¼Œè¦ä¸ç„¶ä¼šç›´æ¥å¹²æ‰ï¼
		deletedOnField, hasDeletedOnField := scope.FieldByName("DeletedOn")

        // ä¸‹é¢çš„å†…å®¹æ˜¯å¯¹ Unscoped çš„æ£€æŸ¥
        // gormçš„Unscopedæ–¹æ³•è®¾ç½®tx.Statement.Unscopedä¸ºtrueï¼›
        // é’ˆå¯¹è½¯åˆ é™¤ä¼šè¿½åŠ SoftDeleteDeleteClauseï¼Œå³è®¾ç½®deleted_atä¸ºæŒ‡å®šçš„æ—¶é—´æˆ³ï¼›
        // è€Œcallbacksçš„Deleteæ–¹æ³•åœ¨db.Statement.Unscopedä¸ºfalseçš„æ—¶å€™æ‰è¿½åŠ 
        // db.Statement.Schema.DeleteClausesï¼Œè€ŒUnscopedåˆ™æ‰§è¡Œçš„æ˜¯ç‰©ç†åˆ é™¤ã€‚

        // é€»è¾‘å¦‚ä¸‹ï¼Œå¦‚æœå­˜åœ¨ å°±è½¯åˆ é™¤ï¼Œå¦‚æœå·²ç»è¢«è½¯åˆ é™¤å•¦ é‚£å°±ç¡¬åˆ é™¤ï¼
		if !scope.Search.Unscoped && hasDeletedOnField {

            // ä¸‹é¢çš„ä¸œè¥¿ å‰é¢çš„ SQLä¸­éœ€è¦åé¢çš„æŒ‡å®šçš„å‚æ•° æ¥è¿›è¡Œå¡«å……ï¼Œæœ€åå» exec æ‰§è¡Œ
            scope.Raw(fmt.Sprintf(
				"UPDATE %v SET %v=%v%v%v",
				scope.QuotedTableName(),
                // QuotedTableName è¿”å› å¼•ç”¨çš„è¡¨å
				scope.Quote(deletedOnField.DBName),
				scope.AddToVars(time.Now().Unix()),
                // CombinedConditionSql è¿”å›ç»„åˆå¥½çš„sql
				addExtraSpaceIfExist(scope.CombinedConditionSql()),
				addExtraSpaceIfExist(extraOption),
			)).Exec()
		} else {
			scope.Raw(fmt.Sprintf(
				"DELETE FROM %v%v%v",
				scope.QuotedTableName(),
				addExtraSpaceIfExist(scope.CombinedConditionSql()),
				addExtraSpaceIfExist(extraOption),
			)).Exec()
		}
	}
}

// è¿™ä¸ªæ–¹æ³•æœ‰ç‚¹ä¸¢å¤šä½™ å°±çœ‹çœ‹string åŠ ä¸€ä¸ªç‰µåˆ¶ç©ºæ ¼ ä½œç”¨æ˜¯åç»­ ä¾æ®æ–‡ä»¶æ‰‹åŠ¨ä¿®æ”¹åº“çš„æ—¶å€™ä½¿ç”¨çš„
// addExtraSpaceIfExist adds a separator
func addExtraSpaceIfExist(str string) string {
	if str != "" {
		return " " + str
	}
	return ""
}

// æœ€åä¾ç„¶ç»™å®ƒï¼ŒæŒ‚å›å»å°±å¥½å•¦
func Setup() {
// ++++
db.Callback().Delete().Replace("gorm:delete", deleteCallback)
// ++++
}

```

# JWT
> è¿™ä¸ªå°èŠ‚ï¼Œä½ å°†å­¦ä¼šå¦‚ä½•åœ¨ginä¸­ä½¿ç”¨ä¸­é—´ä»¶ middwaareï¼Œå’Œä»http headerä¸­è·å–æ•°æ®ï¼Œä»¥åŠjwt éªŒè¯å®ç°
>

éœ€è¦åŸºç¡€çš„Http web service éƒ½éœ€è¦åš jwt éªŒè¯ï¼Œçœ‹çœ‹æ˜¯å¦æ˜¯ç³»ç»Ÿå…è®¸çš„ç”¨æˆ·ï¼Œä¿æŠ¤ç³»ç»Ÿã€‚ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„ï¼Œxxxå¿…é¡»è¦ç™»å½•æ‰èƒ½ä½¿ç”¨ï¼Œç›®å‰è®¸å¤šäº§å“éƒ½æ˜¯ ä»¥ç”¨æˆ·è´¦å· ä¸ºæ ¸å¿ƒï¼Œç„¶åæ‰©å±•å¼€çš„ä¸€äº›åˆ—çš„ä¸šåŠ¡ã€‚

å¯¹äºgoï¼Œgo-gin è€Œè¨€ï¼Œè¦æƒ³åšä¸€ä¸ªjwt è¿˜æ˜¯éå¸¸çš„ç®€å•å’Œç®€æ´çš„ï¼Œè¯·çœ‹ä¸‹é¢çš„é€»è¾‘å’Œå®ç°è¿‡ç¨‹ã€‚

## Tokençš„è§£æå™¨å’Œç”Ÿæˆå™¨
æˆ‘ä»¬é¦–å…ˆæ¥å®šä¹‰ ç”Ÿæˆå™¨å’Œè§£æå™¨ï¼Œæˆ‘ä»¬ä½¿ç”¨æ¥ä¸€ä¸ªåº“ go get -u github.com/dgrijalva/jwt-go

```shell
go get -u github.com/dgrijalva/jwt-go
```

```go
package util

import (
	"time"

	"github.com/BM-laoli/go-gin-example/pkg/setting"
	jwt "github.com/dgrijalva/jwt-go"
)

var jwtSecret = []byte(setting.AppSetting.JwtSecret)
// è¿™ä¸ªè¦ä½¿ç”¨ byte


// å®šä¹‰tokenè§£æå‡ºæ¥çš„æ ¼å¼å’Œç­¾å…¥tokenä¸­çš„æ•°æ®
type Claims struct {
	Username string `json:"username"`
	Password string `json:"password"`
	jwt.StandardClaims
}

// ç”ŸæˆToken
func GenerateToken(username, password string) (string, error) {
	nowTime := time.Now()
	expireTime := nowTime.Add(3 * time.Hour) // è®¾ç½®è¿‡æœŸæ—¶é—´

	claims := Claims{ // å‡†å¤‡æŠŠä¿¡æ¯ç­¾å jwt-go æä¾›
		username,
		password,
		jwt.StandardClaims{
			ExpiresAt: expireTime.Unix(),
			Issuer:    "gin-blog",
		},
	}

	// SigningMethodHS256  + SecretåŠ å¯†
    // ç›®å‰ä¸€å…±æœ‰ä¸‰ç§ crypto.Hash æ–¹æ¡ˆ SigningMethodHS256ã€SigningMethodHS384ã€SigningMethodHS512
	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	token, err := tokenClaims.SignedString(jwtSecret)
    // SignedString ç”Ÿäº§å†…éƒ¨ç­¾å è·å–å®Œæ•´token

	return token, err
}

// è§£ætoken
func ParseToken(token string) (*Claims, error) {
	tokenClaims, err := jwt.ParseWithClaims(token, &Claims{}, // ç”¨äºè§£æé‰´æƒçš„å£°æ˜ï¼Œæ–¹æ³•å†…éƒ¨ä¸»è¦æ˜¯å…·ä½“çš„è§£ç å’Œæ ¡éªŒçš„è¿‡ç¨‹ï¼Œæœ€ç»ˆè¿”å›*Token
		// è¿™ä¸ªæ˜¯å›è°ƒ å¯ä»¥å¤šæ›´å¤šçš„æ“ä½œ
		func(token *jwt.Token) (interface{}, error) {
			return jwtSecret, nil
		})

	if tokenClaims != nil {
		// tokenClaims.Valid éªŒè¯æ˜¯å¦è¿‡æœŸ åŸºäºæ—¶é—´çš„å£°æ˜exp, iat, nbf
		if claims, ok := tokenClaims.Claims.(*Claims); ok && tokenClaims.Valid {
			return claims, nil
		}
	}

	return nil, err
}

```

## ä¸­é—´ä»¶
æˆ‘ä»¬ç»™ginåŠ ä¸€ä¸ªä¸­é—´ä»¶ï¼Œå®ƒçš„ä½œç”¨æ˜¯åœ¨ router è¿›å…¥åˆ° æ­£å¼ä¸šåŠ¡ï¼ˆéœ€è¦ç­¾åï¼‰çš„apiä¹‹å‰ï¼Œåšä¸€æ¬¡éªŒè¯

```go

// ä¸­é—´ä»¶ ç”¨äºå¤„ç†å’Œæ£€æµ‹token æ˜¯å¦æ­£ç¡®
func JWT() gin.HandlerFunc {
	return func(c *gin.Context) {
		var code int
		var data interface{}
		var token string

		code = e.SUCCESS

		var orgToken = c.Request.Header.Get("Authorization")
		if orgToken == "" {
			code = e.INVALID_PARAMS
		} else {
			token = strings.Fields(orgToken)[1]
		}

		if token == "" {
			code = e.INVALID_PARAMS
		} else {
			claims, err := util.ParseToken(token)
			logging.Error(err)
			if err != nil {
				code = e.ERROR_AUTH_CHECK_TOKEN_FAIL
			} else if time.Now().Unix() > claims.ExpiresAt {
				code = e.ERROR_AUTH_CHECK_TOKEN_TIMEOUT
			}
		}

		if code != e.SUCCESS {
			c.JSON(http.StatusUnauthorized, gin.H{
				"code": code,
				"msg":  e.GetMsg(code),
				"data": data,
			})

			c.Abort()
			return
		}

		// æˆåŠŸä¹‹å è°ƒç”¨next è¯´æ˜é€šè¿‡äº†è¿™ä¸ªä¸­é—´ä»¶ å’Œnode æ¯”è¾ƒç±»ä¼¼
		c.Next()
	}
}


// ä½¿ç”¨èµ·æ¥éå¸¸çš„ç®€å• use å°±å¥½å•¦
r.POST("/auth", api.GetAuth)
r.POST("/authRegister", api.Register)
apiv1 := r.Group("/api/v1")
apiv1.Use(jwt.JWT()) // æŸäº›apiä¹‹åçš„éƒ½ä¼šç»è¿‡éªŒè¯ï¼Œä¹‹å‰çš„æ˜¯ä¸å›éªŒè¯çš„ /auth /authRegisteréƒ½ä¸ä¼š
{
    // ++++
    apiv1.GET("/tags", v1.GetTags)
}

```

## å…¶ä»–éƒ¨åˆ†
ä¸»è¦æ˜¯æŒ‡ service å’Œ model ä»¥åŠ controller

```go
// ç¼–å†™å…·ä½“çš„ router å’Œ service ä»¥åŠmodel(ä¸»è¦æ˜¯auth)
// **auth.modle.go**
type Auth struct {
	ID       int    `gorm:"primary_key" json:"id"`
	Username string `json:"username"`
	Password string `json:"password"`
}

func CheckAuth(username, password string) bool {
	// åšæŒçš„æ–¹å¼ä¸åº”è¯¥è¿™æ ·
	// å®ƒåº”è¯¥ åªè¦redisä¸­æœ‰è¿™ä¸ªç™»å½•çš„keyå°±å¯ä»¥è¯æ˜ ç”¨æˆ·å½“å‰çš„ç™»å½•äº†çš„
	var auth Auth
	db.Select("id").Where(Auth{Username: username, Password: password}).First(&auth)
	if auth.ID > 0 {
		return true
	}

	return false
}

func GetUserById(username, password string) (Auth, error) {
	var (
		auth Auth
		err  error
	)

	err = db.Where(Auth{Username: username}).First(&auth).Error
	if err != nil {
		return auth, err
	}
	return auth, nil
}

// useræ³¨å†Œ
func AddAuth(data map[string]interface{}) error {

	pst, err := PasswordHash(data["password"].(string))

	if err != nil {
		return err
	}

	user := &Auth{
		Username: data["name"].(string),
		Password: pst,
	}

	if err := db.Create(&user).Error; err != nil {
		return err
	}
	return nil
}

// å¯†ç åŠ å¯†: ä¼ å…¥å¯†ç   ==> åŠ å¯†åçš„å¯†ç 
func PasswordHash(pwd string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(pwd), 4)
	if err != nil {
		return "", err
	}
	return string(bytes), err
}

// å¯†ç éªŒè¯: ç”¨æˆ·å‘é€è¿‡æ¥çš„å¯†ç  + æ•°æ®åº“ä¸­æŸ¥å‡ºæ¥çš„å¯†ç ===>  bool
func PasswordVerify(pwd string, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(pwd))
	return err == nil
}


// **service å¤„ç†**
type UserType struct {
	Username string `json:"name" valid:"Required; MaxSize(50)"`
	Password string `json:"password" valid:"Required; MaxSize(50)"`
}

// å¢åŠ ç”¨æˆ·
func (a *UserType) AddAuthUser() error {
	article := map[string]interface{}{
		"name":     a.Username,
		"password": a.Password,
	}

	if err := models.AddAuth(article); err != nil {
		return err
	}

	return nil
}

// çœ‹çœ‹æ˜¯å¦ä¸Šæ­£ç¡®çš„å¯ä»¥ é€šè¿‡bcriptç­¾åé€šè¿‡çš„ç”¨æˆ·
func (a *UserType) VerifyUser() (bool, error) {
	article := map[string]interface{}{
		"name":     a.Username,
		"password": a.Password,
	}
	logging.Info("é”™è¯¯", fmt.Sprintf("--->", article))
	findUser, err := models.GetUserById(article["name"].(string), article["password"].(string))
	logging.Info("è·å–åˆ°çš„ç”¨æˆ·æ˜¯", fmt.Sprintf("findUser--->", findUser))
	return models.PasswordVerify(article["password"].(string), findUser.Password), err
}


// **controller æ˜¯**
type UserType struct {
	Username string `json:"name" valid:"Required; MaxSize(50)"`
	Password string `json:"password" valid:"Required; MaxSize(50)"`
}

// ç”Ÿäº§tokenå¹¶è¿”å› ç±»ä¼¼äºç™»å½•
func GetAuth(c *gin.Context) {
	var (
		appG = app.Gin{C: c}
		user UserType
	)

	httpCode, errCode := app.BindAndValidForJSON(c, &user)
	if errCode != e.SUCCESS {
		appG.Response(httpCode, errCode, nil)
		return
	}

	authService := auth_service.UserType{
		Username: user.Username,
		Password: user.Password,
	}

	// 1.æŠŠè¿™ä¸ªç”¨æˆ·åçš„å¯†ç ç»™æ‰¾å‡ºæ¥ ä»æ•°æ®åº“
	// 2. è¿›è¡Œå¯†ç æ ¸å¯¹
	// 3. è‹¥æˆåŠŸå°±ä¸‹å‘tokenç­¾å

	isValid, _ := authService.VerifyUser()

	if !isValid {
		appG.Response(http.StatusInternalServerError, e.ERROR_ADD_TAG_FAIL, nil)
		return
	}

	// å¼€å§‹ç”Ÿäº§token
	token, err2 := util.GenerateToken(authService.Username, "")
	if err2 != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR_ADD_TAG_FAIL, nil)
		return
	}

	appG.Response(http.StatusOK, e.SUCCESS, map[string]interface{}{
		"token": token,
	})
}

func Register(c *gin.Context) {
	var (
		appG = app.Gin{C: c}
		user UserType
	)

	httpCode, errCode := app.BindAndValidForJSON(c, &user)
	if errCode != e.SUCCESS {
		appG.Response(httpCode, errCode, nil)
		return
	}

	authService := auth_service.UserType{
		Username: user.Username,
		Password: user.Password,
	}

	err := authService.AddAuthUser()
	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR_ADD_TAG_FAIL, nil)
		return
	}

	appG.Response(http.StatusOK, e.SUCCESS, nil)
}


// åˆ°mainä¸­è½½å…¥
// è·¯ç”±æ¨¡å—å’Œåˆ†ç»„ ä»¥åŠjwtéªŒè¯ä¸­é—´ä»·
r.GET("/auth", api.GetAuth)
apiv1 := r.Group("/api/v1")
apiv1.Use(jwt.JWT())
{
    // ++++
    apiv1.GET("/tags", v1.GetTags)
}
```

# æ—¥å¿—
æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œæ—¥å¿—å¯¹äºä¸€ä¸ªæ­£ç»çš„ç¨‹åºæ¥è¯´ï¼Œååˆ†çš„é‡è¦ã€‚æˆ‘ä»¬è¿™é‡Œæš‚ä¸”å®ç°ä¸€ä¸ªæœ¬åœ°çš„æ–‡ä»¶æ—¥å¿—ç³»ç»Ÿï¼Œç”¨æ¥è·å–ä¸€äº›ç®€å•çš„æ—¥å¿—ï¼Œæ¯”å¦‚apiçš„è°ƒç”¨æ¬¡æ•°çš„åˆ†æï¼Œå’Œerrorçš„åˆ†æ. æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨åˆ°å…¶ä»–å¤æ‚çš„libï¼Œåªç”¨åˆ°äº† æœ€ç®€å•çš„log åº“ï¼Œç°åœ¨æˆ‘ä»¬å¯¹ä»–è¿›è¡Œä¸€ç‚¹ç‚¹çš„å°æ”¹é€ ã€‚

## æ–‡ä»¶è¯»å†™å·¥å…·ğŸ”§
æ—¢ç„¶æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æŠŠï¼Œæ—¥å¿—å†™å…¥åˆ°.log æ–‡ä»¶ä¸­ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦å¯¹æœ¬åœ°æ–‡ä»¶è¿›è¡Œ åˆ›å»ºè¯»å†™ç­‰æ“ä½œï¼Œä¸ºæ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå·¥å…·pkg æ¥å®Œæˆ å¯¹log file æ–‡ä»¶çš„æ“ä½œ

```go
package logging

import (
	"os"
	"time"
	"fmt"
	"log"
)

var (
	LogSavePath = "runtime/logs/"
	LogSaveName = "log"
	LogFileExt = "log"
	TimeFormat = "20230102"
)

func getLogFilePath() string {
	return fmt.Sprintf("%s", LogSavePath)
}

func getLogFileFullPath() string {
	prefixPath := getLogFilePath()
	suffixPath := fmt.Sprintf("%s%s.%s", LogSaveName, time.Now().Format(TimeFormat), LogFileExt)

	return fmt.Sprintf("%s%s", prefixPath, suffixPath)
}

func openLogFile(filePath string) *os.File {
	_, err := os.Stat(filePath)
/*
ï¼šè¿”å›æ–‡ä»¶ä¿¡æ¯ç»“æ„æè¿°æ–‡ä»¶ã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œä¼šè¿”å›*PathError
type PathError struct {
    Op   string
    Path string
    Err  error
}
*/
	switch {
		case os.IsNotExist(err):
			mkDir()
		case os.IsPermission(err):
			log.Fatalf("Permission :%v", err)
	}

	handle, err := os.OpenFile(filePath, os.O_APPEND | os.O_CREATE | os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Fail to OpenFile :%v", err)
	}

	return handle
}

func mkDir() {
	dir, _ := os.Getwd()
	err := os.MkdirAll(dir + "/" + getLogFilePath(), os.ModePerm)
	if err != nil {
		panic(err)
	}
}
```

ä¸‹é¢æ˜¯æœ‰å…³osçš„ä¸€äº›åŸºç¡€çŸ¥è¯†è¦ç‚¹:

+ <font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">os.IsNotExist</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼šèƒ½å¤Ÿæ¥å—</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">ErrNotExist</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ã€</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">syscall</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">çš„ä¸€äº›é”™è¯¯ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œèƒ½å¤Ÿå¾—çŸ¥æ–‡ä»¶ä¸å­˜åœ¨æˆ–ç›®å½•ä¸å­˜åœ¨</font>
+ <font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">os.IsPermission</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼šèƒ½å¤Ÿæ¥å—</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">ErrPermission</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ã€</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">syscall</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">çš„ä¸€äº›é”™è¯¯ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œèƒ½å¤Ÿå¾—çŸ¥æƒé™æ˜¯å¦æ»¡è¶³</font>
+ <font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">os.OpenFile</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼šè°ƒç”¨æ–‡ä»¶ï¼Œæ”¯æŒä¼ å…¥æ–‡ä»¶åç§°ã€æŒ‡å®šçš„æ¨¡å¼è°ƒç”¨æ–‡ä»¶ã€æ–‡ä»¶æƒé™ï¼Œè¿”å›çš„æ–‡ä»¶çš„æ–¹æ³•å¯ä»¥ç”¨äº I/Oã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œåˆ™ä¸º</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">*PathError</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ã€‚</font>

```go
const (
    // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
    O_RDONLY int = syscall.O_RDONLY // ä»¥åªè¯»æ¨¡å¼æ‰“å¼€æ–‡ä»¶
    O_WRONLY int = syscall.O_WRONLY // ä»¥åªå†™æ¨¡å¼æ‰“å¼€æ–‡ä»¶
    O_RDWR   int = syscall.O_RDWR   // ä»¥è¯»å†™æ¨¡å¼æ‰“å¼€æ–‡ä»¶
    // The remaining values may be or'ed in to control behavior.
    O_APPEND int = syscall.O_APPEND // åœ¨å†™å…¥æ—¶å°†æ•°æ®è¿½åŠ åˆ°æ–‡ä»¶ä¸­
    O_CREATE int = syscall.O_CREAT  // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶
    O_EXCL   int = syscall.O_EXCL   // ä½¿ç”¨O_CREATEæ—¶ï¼Œæ–‡ä»¶å¿…é¡»ä¸å­˜åœ¨
    O_SYNC   int = syscall.O_SYNC   // åŒæ­¥IO
    O_TRUNC  int = syscall.O_TRUNC  // å¦‚æœå¯ä»¥ï¼Œæ‰“å¼€æ—¶
)
```

+ <font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">os.Getwd</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼šè¿”å›ä¸å½“å‰ç›®å½•å¯¹åº”çš„æ ¹è·¯å¾„å</font>
+ <font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">os.MkdirAll</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼šåˆ›å»ºå¯¹åº”çš„ç›®å½•ä»¥åŠæ‰€éœ€çš„å­ç›®å½•ï¼Œè‹¥æˆåŠŸåˆ™è¿”å›</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">nil</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼Œå¦åˆ™è¿”å›</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">error</font>
+ <font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">os.ModePerm</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼š</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">const</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">å®šä¹‰</font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">ModePerm FileMode = 0777</font>

## logå°è£…
```go
// ä¸»è¦æ˜¯å¯¹logçš„ç®€å•å°è£… log æ˜¾ç¤ºçš„æ—¶å€™ï¼Œé¡ºä¾¿æŠŠæœ¬åœ°æ—¥å¿—ä¹Ÿå­˜äº†
package logging

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
)

type Level int

var (
	F *os.File

	DefaultPrefix      = ""
	DefaultCallerDepth = 2

	logger     *log.Logger
	logPrefix  = ""
	levelFlags = []string{"DEBUG", "INFO", "WARN", "ERROR", "FATAL"}
)

const (
	DEBUG Level = iota
	INFO
	WARNING
	ERROR
	FATAL
)

// ä¸»è¦æ˜¯åˆå§‹åŒ–ä¸€ä¸ª è®°å½•ç³»ç»Ÿæ—¥å¿—ç›¸å…³çš„ å‡½æ•°ç”¨æ¥æ”¶é›†å’Œå‘ æœ¬åœ°æ–‡ä»¶å†™å…¥æ”¶é›†åˆ°çš„é”™è¯¯
// è·å–æ–‡ä»¶å†™å…¥æ–‡ä»¶ æ–‡ä»¶åˆ›å»ºä½¿ç”¨äº†osåº“
func Setup() {
	var err error
	filePath := getLogFilePath()
	fileName := getLogFileName()
	F, err = openLogFile(fileName, filePath)

	if err != nil {
		log.Fatalln(err)
	}

	logger = log.New(F, DefaultPrefix, log.LstdFlags)
/*
  log.Newåˆ›å»ºä¸€ä¸ªæ–°çš„æ—¥å¿—è®°å½•å™¨ã€‚å…¶ç­¾åå¦‚ä¸‹ func New(out io.Writer, prefix string, flag int) *Logger {...}
outå®šä¹‰è¦å†™å…¥æ—¥å¿—æ•°æ®çš„IOå¥æŸ„ã€‚
prefixå®šä¹‰æ¯ä¸ªç”Ÿæˆçš„æ—¥å¿—è¡Œçš„å¼€å¤´ã€‚
flagå®šä¹‰äº†æ—¥å¿—è®°å½•å±æ€§    

log.LstdFlags æœ‰ä¸‹é¢çš„è¿™äº›é€‰é¡¹
const (
    Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
    Ltime                         // the time in the local time zone: 01:23:23
    Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
    Llongfile                     // full file name and line number: /a/b/c/d.go:23
    Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
    LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
    LstdFlags     = Ldate | Ltime // initial values for the standard logger
)
*/
}

func Debug(v ...interface{}) {
	setPrefix(DEBUG)

	logger.Println(v)
}

func Info(v ...interface{}) {
	setPrefix(INFO)

	logger.Println(v)
}

func Warn(v ...interface{}) {
	setPrefix(WARNING)
	logger.Println(v)
}

func Error(v ...interface{}) {
	setPrefix(ERROR)
	logger.Println(v)
}

func Fatal(v ...interface{}) {
	setPrefix(FATAL)
	logger.Fatalln(v)
}

func setPrefix(level Level) {
	_, file, line, ok := runtime.Caller(DefaultCallerDepth)
	if ok {
		logPrefix = fmt.Sprintf("[%s][%s:%d]", levelFlags[level], filepath.Base(file), line)
	} else {
		logPrefix = fmt.Sprintf("[%s]", levelFlags[level])
	}

	logger.SetPrefix(logPrefix)
}

```

## æ•ˆæœ
```go
//+++++
// æˆ‘ä»¬åªéœ€è¦å¼•å…¥æˆ‘ä»¬è‡ªå·±çš„ logginç„¶åå».log è®°å½•å°±å¥½å•¦. ä¸‹é¢æ˜¯ä¾‹å­ğŸ‘‡
code := e.INVALID_PARAMS
	if ok {
		...
	} else {
	    for _, err := range valid.Errors {
                logging.Info(err.Key, err.Message)
            }
	}
//+++++

```

è®°å½•çš„æ ¼å¼å¦‚ä¸‹

![](https://cdn.nlark.com/yuque/0/2023/png/1627571/1672898718921-03288477-b985-44d2-80e3-15d291f46022.png)

# ä¼˜é›…é‡å¯
ä¸»è¦çš„ç›®æ ‡è¿˜æ˜¯ï¼Œå¸Œæœ›ç¨‹åºåœ¨æ›¿æ¢çš„æ—¶å€™ï¼Œèƒ½å¤Ÿåšåˆ°çƒ­æ›´æ–°ã€‚æ—¢ç¨‹åºçš„ç§»äº¤èƒ½å¤Ÿè¾¾åˆ°ä¸‹é¢çš„ç›®æ ‡

+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ä¸å…³é—­ç°æœ‰è¿æ¥ï¼ˆæ­£åœ¨è¿è¡Œä¸­çš„ç¨‹åºï¼‰</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ–°çš„è¿›ç¨‹å¯åŠ¨å¹¶æ›¿ä»£æ—§è¿›ç¨‹</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æ–°çš„è¿›ç¨‹æ¥ç®¡æ–°çš„è¿æ¥</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">è¿æ¥è¦éšæ—¶å“åº”ç”¨æˆ·çš„è¯·æ±‚ï¼Œå½“ç”¨æˆ·ä»åœ¨è¯·æ±‚æ—§è¿›ç¨‹æ—¶è¦ä¿æŒè¿æ¥ï¼Œæ–°ç”¨æˆ·åº”è¯·æ±‚æ–°è¿›ç¨‹ï¼Œä¸å¯ä»¥å‡ºç°æ‹’ç»è¯·æ±‚çš„æƒ…å†µ</font>

## <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ä¿¡å·æ˜¯ä»€ä¹ˆï¼Ÿç†è®ºæŒ‡å¯¼</font>
é¦–å…ˆæˆ‘ä»¬äº†è§£ä¸€ä¸‹ï¼Œå½“ä½ åœ¨shellä¸­ ç›´æ¥ ctrl + c çš„æ—¶å€™ï¼Œå®é™…ä¸Šæ˜¯ç»™oså‘é€äº†ä¸€ä¸ªä¿¡å·ï¼Œè¿™ä¸ªä¿¡å·æ ‡è¯† os å°†è¦ä¸ºä½ åšäº›ä»€ä¹ˆã€‚



<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ä¿¡å·æ˜¯ </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">Unix</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> ã€ç±» </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">Unix</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> ä»¥åŠå…¶ä»– </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">POSIX</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> å…¼å®¹çš„æ“ä½œç³»ç»Ÿä¸­è¿›ç¨‹é—´é€šè®¯çš„ä¸€ç§æœ‰é™åˆ¶çš„æ–¹å¼ï¼Œå®ƒæ˜¯ä¸€ç§å¼‚æ­¥çš„é€šçŸ¥æœºåˆ¶ï¼Œç”¨æ¥æé†’è¿›ç¨‹ä¸€ä¸ªäº‹ä»¶ï¼ˆç¡¬ä»¶å¼‚å¸¸ã€ç¨‹åºæ‰§è¡Œå¼‚å¸¸ã€å¤–éƒ¨å‘å‡ºä¿¡å·ï¼‰å·²ç»å‘ç”Ÿã€‚å½“ä¸€ä¸ªä¿¡å·å‘é€ç»™ä¸€ä¸ªè¿›ç¨‹ï¼Œæ“ä½œç³»ç»Ÿä¸­æ–­äº†è¿›ç¨‹æ­£å¸¸çš„æ§åˆ¶æµç¨‹ã€‚æ­¤æ—¶ï¼Œä»»ä½•éåŸå­æ“ä½œéƒ½å°†è¢«ä¸­æ–­ã€‚å¦‚æœè¿›ç¨‹å®šä¹‰äº†ä¿¡å·çš„å¤„ç†å‡½æ•°ï¼Œé‚£ä¹ˆå®ƒå°†è¢«æ‰§è¡Œï¼Œå¦åˆ™å°±æ‰§è¡Œé»˜è®¤çš„å¤„ç†å‡½æ•°ï¼Œ</font>ä¸‹é¢æ˜¯ä¸€äº›å¸¸è§çš„ä¿¡å· ã€‚

| **<font style="color:rgb(59, 62, 72);">å‘½ä»¤</font>** | **<font style="color:rgb(59, 62, 72);">ä¿¡å·</font>** | **<font style="color:rgb(59, 62, 72);">å«ä¹‰</font>** |
| --- | --- | --- |
| <font style="color:rgb(59, 62, 72);">ctrl + c</font> | <font style="color:rgb(59, 62, 72);">SIGINT</font> | <font style="color:rgb(59, 62, 72);">å¼ºåˆ¶è¿›ç¨‹ç»“æŸ</font> |
| <font style="color:rgb(59, 62, 72);">ctrl + z</font> | <font style="color:rgb(59, 62, 72);">SIGTSTP</font> | <font style="color:rgb(59, 62, 72);">ä»»åŠ¡ä¸­æ–­ï¼Œè¿›ç¨‹æŒ‚èµ·</font> |
| <font style="color:rgb(59, 62, 72);">ctrl + \</font> | <font style="color:rgb(59, 62, 72);">SIGQUIT</font> | <font style="color:rgb(59, 62, 72);">è¿›ç¨‹ç»“æŸ å’Œ</font><font style="color:rgb(59, 62, 72);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">dump core</font> |
| <font style="color:rgb(59, 62, 72);">ctrl + d</font> | | <font style="color:rgb(59, 62, 72);">EOF</font> |
| | <font style="color:rgb(59, 62, 72);">SIGHUP</font> | <font style="color:rgb(59, 62, 72);">ç»ˆæ­¢æ”¶åˆ°è¯¥ä¿¡å·çš„è¿›ç¨‹ã€‚è‹¥ç¨‹åºä¸­æ²¡æœ‰æ•æ‰è¯¥ä¿¡å·ï¼Œå½“æ”¶åˆ°è¯¥ä¿¡å·æ—¶ï¼Œè¿›ç¨‹å°±ä¼šé€€å‡ºï¼ˆå¸¸ç”¨äº é‡å¯ã€é‡æ–°åŠ è½½è¿›ç¨‹ï¼‰</font> |


```shell
kill -l
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP
 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR
31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

å¦‚æœæˆ‘ä»¬åœ¨ç¨‹åºå‡çº§çš„æ—¶å€™ï¼Œç›´æ¥ctrl_C æˆ–åˆ™ kill -9 pid éƒ½ä¼šå¯¼è‡´ ï¼Œè¿è¡Œä¸­çš„ç¨‹åºè¢«ææ–­ï¼Œå¯¼è‡´æ­£åœ¨è®¿é—®çš„ç”¨æˆ·é‡åˆ°é—®é¢˜ã€‚é‚£ä¹ˆå¦‚ä½•åšæ‰èƒ½æ— ç—›å‘¢ï¼Ÿ



## å¦‚ä½•åš
  ä¸»è¦çš„æµç¨‹å¦‚ä¸‹

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">1ã€æ›¿æ¢å¯æ‰§è¡Œæ–‡ä»¶æˆ–ä¿®æ”¹é…ç½®æ–‡ä»¶</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">2ã€å‘é€ä¿¡å·é‡</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">SIGHUP</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">3ã€æ‹’ç»æ–°è¿æ¥è¯·æ±‚æ—§è¿›ç¨‹ï¼Œä½†è¦ä¿è¯å·²æœ‰è¿æ¥æ­£å¸¸</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">4ã€å¯åŠ¨æ–°çš„å­è¿›ç¨‹</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">5ã€æ–°çš„å­è¿›ç¨‹å¼€å§‹</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">Accet</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">6ã€ç³»ç»Ÿå°†æ–°çš„è¯·æ±‚è½¬äº¤æ–°çš„å­è¿›ç¨‹</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">7ã€æ—§è¿›ç¨‹å¤„ç†å®Œæ‰€æœ‰æ—§è¿æ¥åæ­£å¸¸ç»“æŸ</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"></font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">æˆ‘ä»¬ä½¿ç”¨ </font>[fvbock/endless](https://github.com/fvbock/endless)<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">  å®ç° </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">Golang HTTP/HTTPS</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> æœåŠ¡é‡æ–°å¯åŠ¨çš„é›¶åœæœº </font>

<font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">endless server</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> </font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ç›‘å¬ä»¥ä¸‹å‡ ç§ä¿¡å·é‡ï¼š</font>

+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">syscall.SIGHUPï¼šè§¦å‘</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">fork</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> </font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">å­è¿›ç¨‹å’Œé‡æ–°å¯åŠ¨</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">syscall.SIGUSR1/syscall.SIGTSTPï¼šè¢«ç›‘å¬ï¼Œä½†ä¸ä¼šè§¦å‘ä»»ä½•åŠ¨ä½œ</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">syscall.SIGUSR2ï¼šè§¦å‘</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">hammerTime</font>
+ <font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">syscall.SIGINT/syscall.SIGTERMï¼šè§¦å‘æœåŠ¡å™¨å…³é—­ï¼ˆä¼šå®Œæˆæ­£åœ¨è¿è¡Œçš„è¯·æ±‚ï¼‰</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">endless</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> æ­£æ­£æ˜¯ä¾é ç›‘å¬è¿™äº›</font>**<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ä¿¡å·é‡</font>**<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼Œå®Œæˆç®¡æ§çš„ä¸€ç³»åˆ—åŠ¨ä½œ</font>

<font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">endless.NewServer</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> è¿”å›ä¸€ä¸ªåˆå§‹åŒ–çš„ </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">endlessServer</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> å¯¹è±¡ï¼Œåœ¨ </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">BeforeBegin</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> æ—¶è¾“å‡ºå½“å‰è¿›ç¨‹çš„ </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">pid</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);">ï¼Œè°ƒç”¨ </font><font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">ListenAndServe</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> å°†å®é™…â€œå¯åŠ¨â€æœåŠ¡</font>

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"></font>

```go
package main

import (
    "fmt"
    "log"
    "syscall"

    "github.com/fvbock/endless"

    "gin-blog/routers"
    "gin-blog/pkg/setting"
)

func main() {
    endless.DefaultReadTimeOut = setting.ReadTimeout
    endless.DefaultWriteTimeOut = setting.WriteTimeout
    endless.DefaultMaxHeaderBytes = 1 << 20
    endPoint := fmt.Sprintf(":%d", setting.HTTPPort)

    server := endless.NewServer(endPoint, routers.InitRouter())
    server.BeforeBegin = func(add string) {
        log.Printf("Actual pid is %d", syscall.Getpid())
    }

    err := server.ListenAndServe()
    if err != nil {
        log.Printf("Server err: %v", err)
    }
}
```

<font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"></font>

ä¸‹é¢æˆ‘ä»¬åªéœ€è¦ ç®€å•çš„éªŒè¯ä¸€ä¸‹å°±å¥½å•¦ï¼Œä¸»è¦éªŒè¯æ­¥éª¤å¦‚ä¸‹

```shell
go build main.go 
# ç¼–è¯‘

./main
# æ‰§è¡Œ

# æ—¥å¿—log
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
...
Actual pid is 48601
# ç›®å‰pid æ˜¯ 48601 ï¼Œç°åœ¨æˆ‘ä»¬æ¥åˆ°å¦ä¸€ä¸ªç»ˆç«¯ å»kill è¿™ä¸ªè¿›ç¨‹ï¼Œä¹‹åä½ ä¼šå‘ç°ï¼ŒåŸæ¥çš„çš„ç»ˆç«¯ 48601è¿™ä¸ª

# æ—¥å¿—log
...
Actual pid is 48601
....

Actual pid is 48755
48601 Received SIGTERM.
48601 [::]:8000 Listener closed.
48601 Waiting for connections to finish...
48601 Serve() returning...
Server err: accept tcp [::]:8000: use of closed network connection

# å¯ä»¥çœ‹åˆ° åˆ fork ä¸€ä¸ª 48755 
# è¿™ä¸ªæ˜¯ä½ å¦‚æœä½ å»è°ƒæ¥å£å®ƒä¾ç„¶èƒ½é€šï¼Œè¯·æ±‚ä¸­çš„ä¹Ÿä¸ä¼šç«‹å³æ–­ï¼Œè€Œæ˜¯å®Œæˆä¹‹åæ‰ä¼šæ–­
```

<font style="color:rgb(44, 62, 80);background-color:rgb(238, 238, 238);">endless</font><font style="color:rgb(59, 62, 72);background-color:rgb(252, 252, 252);"> çƒ­æ›´æ–°æ˜¯é‡‡å–åˆ›å»ºå­è¿›ç¨‹åï¼Œå°†åŸè¿›ç¨‹é€€å‡ºçš„æ–¹å¼</font>



# æ•´ç†ä¸€ä¸‹ç›®å‰ä¸ºæ­¢çš„ä»£ç 
åˆ°ç›®å‰ä¸ºæ­¢æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬éƒ½å®ç°äº†æ€ä¹ˆæ ·çš„åŠŸèƒ½

    - [x] åŸºç¡€çš„config é…ç½®
    - [x] åŸºç¡€çš„ router é…ç½® 
    - [x] åŸºç¡€çš„modle å’Œgorm å•è¡¨æ“ä½œ
    - [x] è¿›é˜¶çš„gorm å…³è”æ“ä½œ
    - [x] spring åŒ–çš„ä¸€äº›æ¦‚å¿µ ï¼ˆservice controller dto entitiesï¼‰
    - [x] ç»Ÿä¸€è¿”å›æ ¼å¼
    - [x] ä¸­é—´ä»¶jwt
    - [x] æ—¥å¿—
    - [x] ä¼˜é›…é‡å¯

æ–‡ä»¶å¤¹ğŸ“ ç»“æ„å¦‚ä¸‹ï¼ˆæˆ‘é‡æ–°åšäº†è°ƒæ•´æŠŠå®ƒï¼Œå¼„æˆäº†ç±»ä¼¼ æˆ‘çš„nest é¡¹ç›®çš„ç»“æ„ï¼Œå½“ç„¶ç»“æ„æ— æ‰€è°“ï¼Œå¤§å®¶éƒ½å¾ˆçµæ´»ï¼Œæˆ‘åªæ˜¯ä¹ æƒ¯äº†è¿™æ ·åšè€Œå·²ï¼‰





